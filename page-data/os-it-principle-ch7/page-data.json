{"componentChunkName":"component---src-templates-post-tsx","path":"/os-it-principle-ch7/","result":{"data":{"markdownRemark":{"html":"<ul>\n<li>컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소 체계를 사용하면 2의 32제곱 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.</li>\n<li>효율적인 운영을 위해 보통 4KB(= 2의 12제곱 byte) 단위로 묶어서 페이지(page)라는 하나의 행정구역을 만들어서 관리한다.</li>\n</ul>\n<h2 id=\"1-주소-바인딩\" style=\"position:relative;\"><a href=\"#1-%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"1 주소 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 주소 바인딩</h2>\n<ul>\n<li>\n<p>프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성되는데 이 주소를 논리적 주소(logical address) 혹은 가상 주소(virtual address)라고 부른다.</p>\n<ul>\n<li>CPU는 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행함.</li>\n<li>각 프로세스마다 독립적으로 할당되며 0번지부터 시작됨.</li>\n</ul>\n</li>\n<li>\n<p>물리적 주소(physical address)는 물리적 메모리에 실제로 올라가는 위치를 말한다.</p>\n<ul>\n<li>물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스가 실행되기 위해서는 해당 프로그램이 물리적 메모리에 올라가 있어야한다.\n또한 CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.</p>\n<ul>\n<li>프로세스의 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩(address binding)이라고 한다.</li>\n</ul>\n</li>\n<li>\n<p>주소 바인딩의 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류할 수 있음.</p>\n<ol>\n<li>\n<p>물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식을 컴파일 타임 바인딩(compile time binding)이라고 부름.</p>\n<ul>\n<li>컴파일 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지 결정한다.</li>\n<li>절대주소로 적재된다는 뜻에서 절대코드(absolute code)를 생성하는 바인딩 방식이라고도 말함.</li>\n<li>물리적 메모리 위치를 변경하고 싶다면 다시 컴파일을 해야하기에 비현실적이고 현대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않음.</li>\n</ul>\n</li>\n<li>\n<p>프로그램 실행이 시작될 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식을 로드 타임 바인딩(load time binding)이라고 한다.</p>\n<ul>\n<li>\n<p>로더(loader)의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다.</p>\n<ul>\n<li>로더란 사용자 프로그램을 메모리에 적재시키는 프로그램</li>\n</ul>\n</li>\n<li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식</li>\n</ul>\n</li>\n<li>\n<p>실행시간 바인딩(execution time binding 또는 run time binding)은 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식.</p>\n<ul>\n<li>CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 함.</li>\n<li>\n<p>기준 레지스터와 한계 레지스터를 포함해 MMU(Memory Management Unit: 메모리 관리 유닛)라는 하드웨어적인 지원이 뒷받침되어야 함.</p>\n<ul>\n<li>MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어냄.</p>\n<ul>\n<li>기준 레지스터는 재배치 레지스터(relocation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있음.</li>\n<li>MMU 기법에서 사용자 프로그램이나 CPU는 논리적 주소만 다룰 뿐, 물리적 주소는 알지 못하며 알 필요도 없음.</li>\n</ul>\n</li>\n<li>\n<p>동일한 주소값이라 하더라도 각 프로세스마다 서로 다른 내용을 담고 있게 되므로 CPU가 논리적 주소 100번지를 참조한다고 했을 때 현재 CPU에서 수행되고 있는 프로세스가 무엇인지에 따라 100번지가 가리키는 내용은 상이해진다.</p>\n<ul>\n<li>MMU 기법에서는 문맥교환으로 프로세스가 바뀔 때마다 재배치 레지스터 값을 그 프로세스에 해당되는 값으로 재설정함.</li>\n</ul>\n</li>\n<li>\n<p>다중 프로그래밍 환경에서 MMU 방식을 사용하여 주소 변환을 했을 때 해당 프로세스의 주소 공간을 벗어나는 경우가 발생할 수 있다.\n이렇게 되면 메모리 보안(memory protection)이 이루어지지 않아 다른 프로그램 영역을 침범하거나 심지어 운영체제 메모리 영역을 변경해 시스템에 치명적인 결과를 초래할 수도 있음.</p>\n<ul>\n<li>이를 방지하기 위해 한계 레지스터를 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>한계 레지스터는 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용되며, 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고 있음.</p>\n<ul>\n<li>CPU가 메모리 참조 요청을 했을 때 그 주소가 한계 레지스터값보다 큰지를 먼저 체크해 물리적 메모리 영역에 대한 보안을 유지하게 됨.</li>\n</ul>\n</li>\n<li>\n<p>먼저 CPU가 요청한 프로세스의 논리적 주소값이 한계 레지스터 내에 저장된 그 프로세스의 크기보다 작은지 확인함</p>\n<ul>\n<li>작다면 재배치 레지스터값을 더해 물리적 주소를 구한 다음 해당 물리적 메모리 위치에 접근하도록 허락함.</li>\n<li>크다면 다른 프로세스 주소 영역에 접근하려는 시도이므로 트랩을 발생시켜 프로세스를 강제종료시킴.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-메모리-관리와-관련된-용어\" style=\"position:relative;\"><a href=\"#2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%9A%A9%EC%96%B4\" aria-label=\"2 메모리 관리와 관련된 용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 메모리 관리와 관련된 용어</h2>\n<ol>\n<li>\n<p>동적로딩(dynamic loading)</p>\n<ol>\n<li>다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나.</li>\n<li>프로세스가 시작될 때 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 해당 부분이 불릴 때 그 부분만을 메모리에 적재하는 방식을 사용함.\n즉, 프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재하는 것을 의미함.</li>\n<li>프로그램 자체에서 구현이 가능하며 운영체제가 라이브러리를 통해 지원할 수도 있음.</li>\n</ol>\n</li>\n<li>\n<p>동적연결(dynamic linking)</p>\n<ol>\n<li>연결(linking)이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과, 이미 컴파일된 라이브러리 파일(library file)들을 묶어 하나의 실행파일을 생성하는 과정을 말함.</li>\n<li>\n<p>동적연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램 실행 시점까지 지연시키는 기법.</p>\n<ul>\n<li>반대 개념인 정적연결(static linking)에서는 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성됨.</li>\n<li>실행파일 크기가 상대적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로 물리적 메모리가 낭비되는 단점이 존재.</li>\n</ul>\n</li>\n<li>동적연결은 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어짐.</li>\n<li>\n<p>실행파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둠.</p>\n<ul>\n<li>라이브러리가 메모리에 이미 존재하면 그 주소의 메모리 위치에 직접 참조하며, 그렇지 않으면 디스크에서 동적 라이브러리 파일을 찾아 메모리에 적재한 후 수행함.</li>\n</ul>\n</li>\n<li>메모리 사용의 효율성을 높일 수 있고 동적연결 기법은 운영체제의 지원을 필요로 함.</li>\n</ol>\n</li>\n<li>\n<p>중첩(overlays)</p>\n<ol>\n<li>프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법.</li>\n<li>초창기 컴퓨터 시스템에서 물리적 메모리의 크기 제약으로 인해 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없을 때, 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 실행이 끝난 후 나머지 부분을 올려 실행하는 기법을 뜻함.</li>\n<li>동적로딩은 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도인 반면, 중첩은 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이었다.</li>\n<li>운영체제 지원 없이 프로그래머에 의해 구현되어야 했으며 손수 구현했다고 해서 수작업 중첩(manual overlays)이라고도 부름.</li>\n</ol>\n</li>\n<li>\n<p>스와핑(swapping)</p>\n<ol>\n<li>\n<p>스와핑이란 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것을 말한다.</p>\n<ul>\n<li>스왑 역역은 백킹스토어(backing store)라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말함.</li>\n<li>파일 시스템은 비휘발성 저장공간임에 비해 스왑 영역은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 짧은 저장공간임</li>\n</ul>\n</li>\n<li>스왑 영역은 충분히 큰 저장공간이어야 하고 어느 정도의 접근 속도가 보장되어야 한다.</li>\n<li>\n<p>스와핑은 프로세스가 종료되어 그 주소 공간을 디스크로 내쫓는 것이 아니라, 특정 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미함.</p>\n<ul>\n<li>디스크에서 메모리로 올리는 작업을 스왑 인(swap in), 메모리에서 디스크로 내리는 작업을 스왑 아웃(swap out)이라고 부름.</li>\n</ul>\n</li>\n<li>스와핑은 스와퍼(swapper)라고 불리는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정함.</li>\n<li>스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것. 즉, 스와핑을 통해 다중 프로그래밍의 정도를 조절할 수 있다.</li>\n<li>컴파일 타임 바인딩 방식이나 로드 타임 바인딩 방식에서는 스왑 인될 때에 원래 존재하던 메모리 위치로 다시 올라가야 하지만 실행시간 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음.</li>\n<li>스와핑에 소요되는 시간은 디스크의 탐색시간(seek time)이나 회전지연시간(rotational latency)보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간(transfer time)이 대부분을 차지함.</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"3-물리적-메모리의-할당-방식\" style=\"position:relative;\"><a href=\"#3-%EB%AC%BC%EB%A6%AC%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"3 물리적 메모리의 할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 물리적 메모리의 할당 방식</h2>\n<ul>\n<li>\n<p>물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉘어 사용됨.</p>\n<ul>\n<li>운영체제 상주 영역은 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, 운영체제 커널이 이곳에 위치하게 됨.</li>\n<li>사용자 프로세스 영역은 물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 이곳에 적재되어 실행됨.</li>\n</ul>\n</li>\n<li>사용자 프로세스 영역에서는 프로세스를 메모리에 올리는 방식에 따라 두 가지로 나누어 볼 수 있음.</li>\n<li>\n<p>연속할당(contiguous allocation) 방식</p>\n<ul>\n<li>각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식.</li>\n<li>물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 함.</li>\n<li>\n<p>고정분할(fixed partition allocation) 방식</p>\n<ul>\n<li>물리적 메모리를 고정된 크기의 분할로 미리 나누어두는 방식</li>\n</ul>\n</li>\n<li>\n<p>가변분할(variable partition allocation) 방식</p>\n<ul>\n<li>미리 나누어놓지 않은 채 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>불연속할당(noncontiguous allocation) 방식</p>\n<ul>\n<li>하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식.</li>\n<li>페이징 기법과 세그먼테이션 기법, 페이즈드 세그먼테이션 기법 등이 있음.</li>\n</ul>\n</li>\n<li>\n<p>연속할당 방식</p>\n<ul>\n<li>프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식.</li>\n<li>\n<p>고정분할 방식</p>\n<ul>\n<li>물리적 메모리를 주어진 개수만큼의 영구적인 분할(partition)로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 함.</li>\n<li>분할의 크기는 모두 동일하게 할 수도 있고 서로 다르게 할 수도 있음.</li>\n<li>하나의 분할에는 하나의 프로그램만을 적재할 수 있어 고정분할 방식은 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한된다는 점에서 가변분할 방식에 비해 융통성이 떨어짐.</li>\n<li>외부조각과 내부조각이 발생할 수 있음.</li>\n<li>\n<p>외부조각</p>\n<ul>\n<li>프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간.</li>\n</ul>\n</li>\n<li>\n<p>내부조각</p>\n<ul>\n<li>프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간을 의미.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>가변분할 방식</p>\n<ul>\n<li>메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식.</li>\n<li>내부조각은 발생하지 않으나 외부조각이 발생할 가능성이 있음.</li>\n<li>가변분할 방식에서는 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지 결정하는 것이 문제이고 이를 동적 메모리 할당 문제(dynamic storage-allocation problem)이라고 부름.</li>\n<li>가용 공간들을 좀 더 효율적으로 관리하기 위해 운영체제는 이미 사용 중인 메모리 공간과 사용하고 있지 않은 가용 공간에 대한 정보를 각각 유지하고 있음.</li>\n<li>\n<p>동적 메모리 할당 문제를 해결하는 대표적인 방법으로는 세 가지가 있음.</p>\n<ul>\n<li>\n<p>최초적합(first-fit) 방법</p>\n<ul>\n<li>크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당하는 방법.</li>\n<li>가용 공간을 모두 탐색하는 방법이 아니므로 시간적인 측면에서 효율적.</li>\n</ul>\n</li>\n<li>\n<p>최적적합(best-fit) 방법</p>\n<ul>\n<li>크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당하는 방법.</li>\n<li>가용 공간 리스트가 크기순으로 정렬되어 있지 않은 경우 모든 가용 공간 리스트를 탐색해야 하므로 시간적 오버헤드가 발생하고 다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점이 있지만 공간적인 측면에서 효율적.</li>\n</ul>\n</li>\n<li>\n<p>최악적합(worst-fit) 방법</p>\n<ul>\n<li>가장 크기가 큰 곳에 새로운 프로그램을 할당하는 방법.</li>\n<li>모든 가용 공간 리스트를 탐색해야 하는 오버헤드가 발생하고 상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제점이 있음.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>외부조각 문제를 해결하기 위해 컴팩션(compaction)이라는 방법이 있음.</p>\n<ul>\n<li>물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법.</li>\n<li>현재 수행 중인 프로세스의 메모리상 위치를 상당 부분 이동시켜야 하므로 비용이 매우 많이 드는 작업.</li>\n<li>수행 중인 프로세스 물리적 메모리 위치를 옮겨야 하므로 실행시간 바인딩 방식이 지원되는 환경에서만 수행될 수 있음.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>불연속할당 기법</p>\n<ul>\n<li>하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법을 의미함.</li>\n<li>페이징 기법, 세그먼테이션 기법, 페이지드 세그먼테이션 기법 등이 있음.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-페이징-기법\" style=\"position:relative;\"><a href=\"#4-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\" aria-label=\"4 페이징 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 페이징 기법</h2>\n<ul>\n<li>페이징(paging) 기법이란 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식.</li>\n<li>\n<p>페이징 기법에서는 물리적 메모리를 페이지와 동일한 크기의 프레임(frame)으로 미리 나누어둔다.</p>\n<ul>\n<li>메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로, 빈 프레임이 있으면 어떤 위치이든 사용될 수 있다.\n따라서 동적 메모리 할당 문제가 발생하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>주소 변환 절차가 연속할당 방식에 비해 다소 복잡하다.</p>\n<ul>\n<li>하나의 프로세스라 하더라도 페이지 단위로 물리적 메모리에 올리는 위치가 상이하므로, 논리적 주소를 물리적 주소로 변환하는 작업이 페이지 단위로 이루어져야 하기 때문이다.</li>\n<li>페이지별 주소 변환 정보를 유지하고 있어야 하므로 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블을 가지며, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/146325391-f9c3e38e-0fd4-4ace-9eec-f820553da91d.png\" alt=\"Untitled (74)\"></p>\n</li>\n<li>페이징 기법에서는 빈 공간은 어느 곳이든 활용할 수 있어서 외부조각 문제가 발생하지 않는다.\n그러나 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 프로세스 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부조각이 발생할 가능성이 있다.</li>\n<li>\n<p>주소 변환 기법</p>\n<ol>\n<li>페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환(address translation)에 사용한다.</li>\n<li>페이지 번호는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스(index)로 사용되고, 해당 인덱스의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소(base address), 즉 시작 위치가 저장된다.\n따라서 p번째 페이지가 위치한 물리적 메모리의 시작 위치를 알고 싶다면 해당 프로세스 페이지 테이블에서 p번째 항목을 찾아보면 된다.</li>\n<li>페이지 오프셋은 하나의 페이지 내에서의 변위를 알려주므로 기준 주소값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 알 수 있다.</li>\n</ol>\n</li>\n<li>\n<p>페이지 테이블의 구현</p>\n<ol>\n<li>페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료구조로, 물리적 메모리에 위치하게 된다.</li>\n<li>\n<p>CPU에서 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용하는데, 각각 페이지 테이블 기준 레지스터(page-table base register)와 페이지 테이블 길이 레지스터(page-table length register)로 불린다.</p>\n<ul>\n<li>페이지 테이블 기준 레지스터는 메모리 내에서의 페이지 테이블의 시작 위치를 가리킴.</li>\n<li>페이지 테이블 길이 레지스터는 페이지 테이블의 크기를 보관함.</li>\n</ul>\n</li>\n<li>\n<p>페이징 기법에서의 메모리 접근 연산은 주소 변환을 위해 페이지 테이블에 접근하는 것, 변환된 주소에서 실제 데이터에 접근하는 것, 이렇게 두 번의 메모리 접근을 필요로 함.</p>\n<ul>\n<li>이러한 오버헤드를 줄이고 메모리 접근 속도를 향상시키기 위해 TLB(Translation Look-aside Buffer)라고 불리는 고속의 주소 변환용 하드웨어 캐시가 사용된다.</li>\n</ul>\n</li>\n<li>\n<p>TLB는 비싸기 때문에 페이지 테이블의 모든 정보를 담을 수는 없으며, 빈번히 참조되는 페이지에 대한 주소 변환 정보만을 담게 됨.</p>\n<ul>\n<li>요청된 페이지 번호가 TLB에 존재한다면 곧바로 대응하는 물리적 메모리의 프레임 번호를 얻을 수 있다.</li>\n<li>존재하지 않는 경우에는 메인 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아내야 한다.</li>\n<li>주소 변환 정보는 프로세스별로 다 다르기 때문에 문맥교환 시 이전 프로세스의 주소 변환 정보를 담고 있던 TLB 내용은 모두 지워버려야 함.</li>\n</ul>\n</li>\n<li>\n<p>페이지 테이블과 TLB에 저장되어 있는 정보는 그 구조가 조금 다르다.</p>\n<ul>\n<li>페이지 테이블에는 모든 페이지에 대한 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어 있다.</li>\n<li>TLB는 모든 페이지에 대한 주소 변환 정보를 가지고 있지 않기 때문에 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어야 한다.</li>\n</ul>\n</li>\n<li>\n<p>TLB를 통한 주소 변환을 위해서 TLB의 모든 항목(entry)을 다 찾아봐야 하는 오버헤드가 발생하는데 이를 줄이기 위해 병렬탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용함.</p>\n<ul>\n<li>병렬탐색 기능이란 TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능을 뜻함.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>계층적 페이징</p>\n<ol>\n<li>페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 2단계 페이징(two-level paging) 기법을 사용함.</li>\n<li>\n<p>2단계 페이징 기법에서는 주소 변환을 위해 외부 페이지 테이블과 내부 페이지 테이블의 두 단계에 걸친 페이지 테이블을 사용함.</p>\n<ul>\n<li>사용 메모리 공간을 줄여 공간적인 이득을 볼 수 있지만, 접근 테이블 수가 증가하므로 시간적인 손해가 뒤따르게 됨.</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 주소 변환을 위한 메모리 공간 낭비 역시 더 심각해지게 됨.</p>\n<ul>\n<li>2단계를 넘어 3단계, 4단계에 이르는 다단계 페이지 테이블이 필요하게 됨.</li>\n<li>다단계 페이지 테이블을 사용하면 페이지 테이블을 위해 사용되는 메모리 공간의 소모는 줄일 수 있지만 그만큼 메모리에 대한 접근 횟수가 많아지기 때문에 메모리 접근시간이 크게 늘어나는 문제가 발생할 수 있음</li>\n<li>이에 시간적인 오버헤드를 줄이기 위해 TLB를 사용하는 것이 효과적.</li>\n<li>TLB를 사용하면 4단계로 구성해도 시간 오버헤드가 그다지 크지 않으면서 메모리 공간의 효율적인 사용 효과는 매우 클 것으로 기대할 수 있음.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>역페이지 테이블</p>\n<ol>\n<li>\n<p>역페이지 테이블(inverted page table) 기법은 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식.</p>\n<ul>\n<li>즉, 논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라 물리적 주소에 대해 테이블을 만드는 것.</li>\n<li>각 프로세스마다 페이지 테이블을 두지 않고, 시스템 전체에 페이지 테이블을 하나만 두는 방법.</li>\n<li>페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담고 있게 됨.</li>\n</ul>\n</li>\n<li>\n<p>역페이지 테이블에 주소 변환 요청이 들어오면, 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해 페이지 전체를 다 탐색해야 하는 어려움이 있음.</p>\n<ul>\n<li>역페이지 테이블은 연관 레지스터에 보관해 테이블 전체 항목에 대한 병렬탐색을 가능하게 함으로써 시간적 효율성을 꾀하게 됨.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>공유 페이지</p>\n<ol>\n<li>\n<p>공유 코드(shared code)는 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드를 말함.</p>\n<ul>\n<li>재진입 가능 코드(re-entrant code), 순수 코드(pure code)라고도 불리며 읽기전용(read-only)의 특성을 가지고 있음.</li>\n</ul>\n</li>\n<li>\n<p>공유 페이지(shared page)란 공유 코드를 담고 있는 페이지를 말한다.</p>\n<ul>\n<li>공유 페이지는 여러 프로세스에 의해 공유되는 페이지이므로 물리적 메모리에 하나만 적재되어 메모리를 좀 더 효율적으로 사용할 수 있게 한다.</li>\n</ul>\n</li>\n<li>공유 코드는 읽기전용의 성질을 가져야 할 뿐 아니라 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재해야 하는 제약점이 있다.\n즉, 공유 페이지는 그 페이지를 공유하는 모든 프로세스의 주소 공간에서 동일한 페이지 번호를 가져야 한다.</li>\n<li>\n<p>공유 페이지와 대비되는 개념으로 사유 페이지(private page)가 있는데, 이것은 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지를 말한다.</p>\n<ul>\n<li>해당 프로세스의 논리적 주소 공간 중 어떠한 위치에 있어도 무방함.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>메모리 보호</p>\n<ol>\n<li>페이지 테이블의 각 항목에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 보호비트(protection bit)와 유효-무효 비트(valid-invalid bit)를 두고 있다.</li>\n<li>\n<p>보호비트는 각 페이지에 대한 접근 권한의 내용을 담고 있다.</p>\n<ul>\n<li>각 페이지에 대해 읽기-쓰기/읽기전용 등의 접근 권한을 설정하는 데에 사용됨.</li>\n</ul>\n</li>\n<li>\n<p>유효-무효 비트는 해당 페이지의 내용이 유효한지에 대한 내용을 담고 있다.</p>\n<ul>\n<li>'유효'로 세팅되어 있으면 해당 메모리 프레임에 그 페이지가 존재함을 뜻하며, 따라서 접근이 허용된다.</li>\n<li>'무효'로 세팅되어 있으면 프로세스가 그 주소 부분을 사용하지 않거나, 해당 페이지가 물맂걱 메모리에 올라와 있지 않고 백킹스토어에 존재해 해당 메모리 프레임에 유효한 접근 권한이 없다는 의미를 지닌다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-세그먼테이션\" style=\"position:relative;\"><a href=\"#5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\"5 세그먼테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 세그먼테이션</h2>\n<ul>\n<li>세그먼테이션(segmentation) 기법은 프로세스의 주소 공간을 의미 단위의 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법이다.</li>\n<li>\n<p>하나의 프로세스를 구성하는 주소 공간은 코드, 데이터, 스택 등의 의미 있는 단위들로 구성되는데 세그먼트는 이와 같이 주소 공간을 기능 단위 또는 의미 단위로 나눈 것을 뜻함.</p>\n<ul>\n<li>프로세스 주소 공간 전체를 하나의 세그먼트로 볼 수도 있으며, 일반적으로는 코드, 데이터, 스택 등의 기능 단위로 세그먼트를 정의한다.</li>\n<li>논리적인 단위로 나눈 것이기 때문에 그 크기가 균일하지 않다.</li>\n</ul>\n</li>\n<li>페이징과 유사하나 의미 단위의 세그먼트로 나누어 관리하므로, 크기가 균일하지 않은 세그먼트들을 메모리에 적재하는 부가적인 관리 오버헤드가 뒤따르게 됨.</li>\n<li>\n<p>논리적 주소가 &#x3C;세그먼트 번호, 오프셋>으로 나뉘어 사용됨.</p>\n<ul>\n<li>세그먼트 번호는 해당 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지를 나타냄.</li>\n<li>오프셋은 그 세그먼트 내에서 얼마만큼 떨어져 있는지에 대한 정보를 나타냄.</li>\n</ul>\n</li>\n<li>\n<p>세그먼트 테이블의 각 항목은 기준점(base)과 한계점(limit)을 가지고 있음.</p>\n<ul>\n<li>기준점은 물리적 메모리에서 그 세그먼트의 시작 위치를 나타냄</li>\n<li>한계점은 그 세그먼트의 길이를 나타냄.</li>\n<li>세그먼트의 길이가 균일하지 않으므로 길이 정보를 함께 보관하고 있는 것.</li>\n</ul>\n</li>\n<li>\n<p>세그먼테이션 기법에서도 세그먼트 테이블 기준 레지스터(Segment-Table Base Register: STBR)와 세그먼트 테이블 길이 레지스터(Segment-Table Length Register: STLR)로 사용하게 됨.</p>\n<ul>\n<li>세그먼트 테이블 기준 레지스터는 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리 어느 위치에 있는지 그 시작 주소를 담고 있음.</li>\n<li>세그먼트 테이블 길이 레지스터는 그 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 세그먼트의 개수를 나타낸다.</li>\n</ul>\n</li>\n<li>\n<p>세그먼테이션 기법에서는 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확임함.</p>\n<ul>\n<li>\n<p>요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인가 하는 점</p>\n<ul>\n<li>만약 그렇지 않다면 존재하지 않는 세그먼트에 대한 접근 시도이므로 예외상황을 발생시켜 메모리 접근을 봉쇄해야 할 것.</li>\n</ul>\n</li>\n<li>\n<p>논리적 주소의 오프셋값이 그 세그먼트의 길이보다 작은 값인가 하는 점.</p>\n<ul>\n<li>세그먼트 테이블의 한계점과 요청된 논리적 주소의 오프셋값을 비교해 확인하게 됨.</li>\n<li>만약 세그먼트 길이를 넘어서는 오프셋 위치에 대한 접근 시도라면 예외상황을 발생시킨다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>페이징 기법과 마찬가지로 보호비트, 유효비트를 두고 공유 세그먼트(shared segment) 개념을 지원함.</li>\n<li>\n<p>세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적임.</p>\n<ul>\n<li>주소 공간의 일부를 공유하거나 특정 주소 공간에 읽기전용 등의 접근 권한 제어를 하고자 할 경우, 이는 어떤 의미 단위로 이루어지지 단순히 크기 단위로 수행되지 않기 때문</li>\n</ul>\n</li>\n<li>\n<p>의미 단위로 나누기에 세그먼트의 길이가 균일하지 않아서 외부조각이 발생하게 되며, 어느 가용 공간에 할당할 것인지 결정하는 문제가 발생함.</p>\n<ul>\n<li>가변분할 방식의 문제와 동일한 범주의 문제라 할 수 있다.</li>\n<li>최초적합 방식과 최적적합 방식을 사용해 할당한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-페이지드-세그먼테이션\" style=\"position:relative;\"><a href=\"#6-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%93%9C-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\"6 페이지드 세그먼테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 페이지드 세그먼테이션</h2>\n<ul>\n<li>페이징과 세그먼테이션 두 기법의 장점만을 취하는 주소 변환 기법으로 페이지드 세그먼테이션(paged segmentation) 기법이 있다.</li>\n<li>\n<p>세그먼테이션 기법과 마찬가지로 프로그램을 의미 단위의 세그먼트로 나눈다.</p>\n<ul>\n<li>단, 반드시 동일한 크기 페이지들의 집합으로 구성되어야 하고 물리적 메모리에 적재하는 단위는 페이지 단위로 한다.</li>\n<li>즉, 페이지드 세그먼테이션 기법에서는 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 외부조각 문제를 해결하며, 동시에 세그먼트 단위로 공유나 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소한다.</li>\n</ul>\n</li>\n<li>주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용함.</li>\n<li>\n<p>논리적 주소의 상위 비트인 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목에 접근함.</p>\n<ul>\n<li>세그먼트 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 들어 있음.</li>\n</ul>\n</li>\n<li>세그먼트 길이값과 오프셋값을 비교해서 오프셋이 크다면 트랩을 발생시킨다.</li>\n<li>그렇지 않을 경우 오프셋값을 다시 상위, 하위 비트로 나누어 상위 비트는 그 세그먼트 내에서의 페이지 번호로 사용하고 하위 비트는 페이지 내에서의 변위로 사용함.</li>\n<li>세그먼트 테이블의 항목을 통해 세그먼트를 위한 페이지 테이블의 시작 위치를 얻었으므로, 그 위치에서 페이지 번호만큼 떨어진 페이지 테이블 항목으로부터 물리적 메모리의 페이지 프레임 위치를 얻게 됨.</li>\n<li>이 위치에서 오프셋의 하위 비트값인 페이지 내 변위만큼 떨어진 곳이 바로 원하는 물리적 메모리 주소가 됨.</li>\n</ul>","excerpt":"컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소 체계를 사용하면 2의 32제곱 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다. 효율적인 운영을 위해 보통 4KB(= 2의 12제곱 byte) 단위로 묶어서 페이지…","tableOfContents":"<ul>\n<li><a href=\"/os-it-principle-ch7/#1-%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9\">1. 주소 바인딩</a></li>\n<li><a href=\"/os-it-principle-ch7/#2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%9A%A9%EC%96%B4\">2. 메모리 관리와 관련된 용어</a></li>\n<li><a href=\"/os-it-principle-ch7/#3-%EB%AC%BC%EB%A6%AC%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\">3. 물리적 메모리의 할당 방식</a></li>\n<li><a href=\"/os-it-principle-ch7/#4-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\">4. 페이징 기법</a></li>\n<li><a href=\"/os-it-principle-ch7/#5-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\">5. 세그먼테이션</a></li>\n<li><a href=\"/os-it-principle-ch7/#6-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%93%9C-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\">6. 페이지드 세그먼테이션</a></li>\n</ul>","fields":{"slug":"/os-it-principle-ch7/"},"frontmatter":{"title":"[운영체제와 정보기술의 원리] 7. 메모리 관리","date":"Oct 16, 2021","tags":["os","book"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/os-it-principle-ch7/","series":[],"lastmod":"2021-10-16"}},"staticQueryHashes":["2027115977","694178885"]}