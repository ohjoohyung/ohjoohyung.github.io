{"componentChunkName":"component---src-templates-post-tsx","path":"/pojo-vs-java-beans/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"pojo-plain-old-java-object\" style=\"position:relative;\"><a href=\"#pojo-plain-old-java-object\" aria-label=\"pojo plain old java object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO (Plain Old Java Object)</h2>\n<p>POJO는 Plain Old Java Object의 준말로 말 그대로 오래된 방식의 간단한 자바 오브젝트라는 뜻이다.<br>\nJava EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 \"무거운\" 객체를 만들게 된 것에 반발해서 사용하게 된 용어로서 2000년 9월 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등이 처음 사용하기 시작했다.<br>\n과거 EJB, Strust같은 프레임워크는 비즈니스 로직을 구현하기 위한 클래스를 코딩할 때 프레임워크의 특정 인터페이스 등의 상속을 강요하였고, 그 결과 비즈니스 로직을 코딩해야할 시간에 상속을 구현하기 위한 관용적인 코딩 작업을 불필요하게 해야 했었다.<br>\n객체지향의 가장 중요한 개념 중 하나인 느슨한 의존관계를 역행하는 이런 침투적인 프레임워크의 문제점을 강조하기 위해 이 말을 처음 사용하기 시작하였다.<br>\n이 후 POJO는 주로 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않은 자바 오브젝트를 지칭하는 말로 사용되었다. 스프링 프레임워크는 POJO 방식의 프레임워크라고 한다.</p>\n<br/>\n<h2 id=\"java-beans\" style=\"position:relative;\"><a href=\"#java-beans\" aria-label=\"java beans permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java Beans</h2>\n<p>Java Beans는 데이터를 표현하기 위한 Java 클래스를 만들 때의 규약이다.<br>\n아래의 규칙을 지킨 Java 클래스는 Java Beans라고 부른다.  </p>\n<ul>\n<li>모든 클래스의 프로퍼티는 private이며 getter, setter 메서드로 제어한다.</li>\n<li>인자가 없는 public 생성자가 있어야 한다.</li>\n<li>Serializable 인터페이스를 구현해야 한다.  </li>\n</ul>\n<p>Java Beans 규약은 Java EE 프레임워크에서 데이터를 저장할 Java 클래스를 만들 때 제안하는 일종의 규약이다.</p>\n<br/>\n<h2 id=\"pojo--java-beans\" style=\"position:relative;\"><a href=\"#pojo--java-beans\" aria-label=\"pojo  java beans permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO == Java Beans?</h2>\n<p>NO!<br>\nJava Beans는 POJO이다.<br>\n그러나 POJO는 Java Beans가 아니다.<br>\nPOJO가 Java Beans보다 더 넓은 개념이다.</p>\n<br/>\n<h2 id=\"spring에서-사용하는-bean은\" style=\"position:relative;\"><a href=\"#spring%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-bean%EC%9D%80\" aria-label=\"spring에서 사용하는 bean은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring에서 사용하는 Bean은?</h2>\n<p>스프링 빈이란 자바 객체를 뜻한다.<br>\n스프링 컨테이너에서 자바 객체가 만들어 지게 되면 이 객체를 스프링 빈이라고 부르는 것이다.<br>\n스프링 빈과 자바 일반 객체와의 차이점은 없다. 다만 스프링 컨테이너에서 만들어지는 객체를 스프링 빈이라고 부를 뿐이다.<br>\n스프링 빈은 설정 메타데이터(xml, 애노테이션)에 의해 생성이 된다.</p>\n<br/>\n<h2 id=\"아무-객체나-bean-등록을-해도-될까\" style=\"position:relative;\"><a href=\"#%EC%95%84%EB%AC%B4-%EA%B0%9D%EC%B2%B4%EB%82%98-bean-%EB%93%B1%EB%A1%9D%EC%9D%84-%ED%95%B4%EB%8F%84-%EB%90%A0%EA%B9%8C\" aria-label=\"아무 객체나 bean 등록을 해도 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아무 객체나 Bean 등록을 해도 될까?</h2>\n<p>NO!<br>\n스프링 빈은 근본적으로 쓰레드 세이프하지 않다.<br>\n왜?<br>\n일단 그렇게 만들어져있지도 않을 뿐더러 빈 등록을 한다는 것은 싱글톤으로 관리를 한다는 뜻이다.<br>\n객체 인스턴스를 하나만 생성해서 공유하는  싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.<br>\n즉, 무상태(stateless)로 설계해야 한다.</p>\n<ul>\n<li>특정 클라이언트에 의존적인 필드가 있으면 안된다.</li>\n<li>특정 클라이언트가 값은 변경할 수 있는 필드가 있으면 안된다.</li>\n<li>가급적 읽기만 가능해야 한다.</li>\n<li>필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.</li>\n</ul>\n<p>스프링 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.</p>\n<br/>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://www.hanumoka.net/2019/01/06/java-20190106-java-pojo-vs-bean/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.hanumoka.net/2019/01/06/java-20190106-java-pojo-vs-bean/</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/Plain_Old_Java_Object\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ko.wikipedia.org/wiki/Plain<em>Old</em>Java_Object</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction</a></li>\n<li><a href=\"https://endorphin0710.tistory.com/93\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://endorphin0710.tistory.com/93</a></li>\n<li>김영한님 스프링 core 수업</li>\n</ul>","excerpt":"POJO (Plain Old Java Object) POJO는 Plain Old Java Object의 준말로 말 그대로 오래된 방식의 간단한 자바 오브젝트라는 뜻이다. Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된…","tableOfContents":"<ul>\n<li><a href=\"/pojo-vs-java-beans/#pojo-plain-old-java-object\">POJO (Plain Old Java Object)</a></li>\n<li><a href=\"/pojo-vs-java-beans/#java-beans\">Java Beans</a></li>\n<li><a href=\"/pojo-vs-java-beans/#pojo--java-beans\">POJO == Java Beans?</a></li>\n<li><a href=\"/pojo-vs-java-beans/#spring%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-bean%EC%9D%80\">Spring에서 사용하는 Bean은?</a></li>\n<li><a href=\"/pojo-vs-java-beans/#%EC%95%84%EB%AC%B4-%EA%B0%9D%EC%B2%B4%EB%82%98-bean-%EB%93%B1%EB%A1%9D%EC%9D%84-%ED%95%B4%EB%8F%84-%EB%90%A0%EA%B9%8C\">아무 객체나 Bean 등록을 해도 될까?</a></li>\n<li><a href=\"/pojo-vs-java-beans/#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>","fields":{"slug":"/pojo-vs-java-beans/"},"frontmatter":{"title":"POJO vs Java Beans","date":"Jun 13, 2021","tags":["java","spring"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/pojo-vs-java-beans/","series":[],"lastmod":"2021-06-13"}},"staticQueryHashes":["2027115977","694178885"]}