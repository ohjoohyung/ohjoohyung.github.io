{"componentChunkName":"component---src-templates-post-tsx","path":"/effective-java-item19/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"상속을-고려한-설계와-문서화란\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%84%A4%EA%B3%84%EC%99%80-%EB%AC%B8%EC%84%9C%ED%99%94%EB%9E%80\" aria-label=\"상속을 고려한 설계와 문서화란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속을 고려한 설계와 문서화란?</h2>\n<p>상속을 고려한 설계와 문서화란 정확히 무얼 뜻할까?</p>\n<p>우선, 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.<br>\n즉, 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.</p>\n<p>더 넓게 말하면, 재정의 가능(public과 protected 메서드 중 final이 아닌 모든 메서드) 메서드를 호출할 수 있는 모든 상황을\n문자로 남겨야 한다. 예를 들어 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있따.</p>\n<br/>\n<h2 id=\"문서화의-예\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%84%9C%ED%99%94%EC%9D%98-%EC%98%88\" aria-label=\"문서화의 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문서화의 예</h2>\n<p>API 문서의 메서드 설명 끝에서 종종 \"Implementation Requirements\"로 시작하는 절을 볼 수 있는데,\n그 메서드의 내부 동작 방식을 설명하는 곳이다.<br>\n메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해준다.\n@implSpec 태그는 자바 8에서 처음 도입되어 자바 9부터 본격적으로 사용되기 시작했다.</p>\n<p>java.util.AbstractCollection에서 발췌한 예이다.\n<img src=\"https://user-images.githubusercontent.com/62014888/153215654-b9df45fa-a39d-4223-88ff-06879490eb41.png\" alt=\"image\"></p>\n<p>클래스를 안전하게 상속할 수 있도록 하려면 (상속만 아니었다면 기술하지 않았어야 할) 내부 구현 방식을 설명해야만 한다.</p>\n<p>내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다.<br>\n효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는\n훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.</p>\n<p>java.util.AbstractList의 removeRange 메서드를 예로 살펴보자.\n<img src=\"https://user-images.githubusercontent.com/62014888/153217238-0de95d1c-5e1d-4355-9e3a-0c4e636c8249.png\" alt=\"image\"></p>\n<p>List 구현체 최종 사용자는 removeRange 메서드에 관심이 없다. 그럼에도 이 메서드를\n제공한 이유는 단지 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서다.</p>\n<p>상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지는 어떻게 결정할까?<br>\n심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선이다.\nprotected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 한다. 한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록\n주의해야 한다.</p>\n<p>상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일'하다.<br>\n꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다.<br>\n거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 크다.<br>\n상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.</p>\n<p>또한, 상속하려는 사람을 위해 덧붙인 설명은 단순히 그 클래스의 인스턴스만 만들어 사용할\n프로그래머에게는 필요 없는 군더더기일 뿐이다.</p>\n<br/>\n<h2 id=\"주의할-점\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의할 점</h2>\n<p>상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.<br>\n상위 클래스의 생성자가 하위 클래스 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가\n하위 클래스의 생성자보다 먼저 호출된다. 이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면\n의도대로 동작하지 않을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 재정의 가능 메서드를 호출하는 생성자 - 따라 하지 말 것! (115쪽)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Super</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 잘못된 예 - 생성자가 재정의 가능 메서드를 호출한다.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">overrideMe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">overrideMe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 생성자에서 호출하는 메서드를 재정의했을 때의 문제를 보여준다. (126쪽)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Sub</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Super</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 초기화되지 않은 final 필드. 생성자에서 초기화한다.</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Instant</span> instant<span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Sub</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        instant <span class=\"token operator\">=</span> <span class=\"token class-name\">Instant</span><span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 재정의 가능 메서드. 상위 클래스의 생성자가 호출한다.</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">overrideMe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>instant<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Sub</span> sub <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Sub</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        sub<span class=\"token punctuation\">.</span><span class=\"token function\">overrideMe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 프로그램이 instant를 두 번 출력하리라 기대했겠지만, 첫 번째는\nnull을 출력한다. 상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴트 필드를\n초기화하기도 전에 overrideMe를 호출하기 때문이다.\n따라서 이 프로그램에서는 final 필드의 상태가 두 가지다. (정상이라면 단 하나뿐)<br>\n만약 overrideMe에서 instant 객체의 메서드를 호출하려 한다면 상위 클래스 생성자에서\nNullPointerException이 발생하게 될 것이다.</p>\n<ul>\n<li>private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.</li>\n</ul>\n<br/>\n<h3 id=\"cloneable-serializable\" style=\"position:relative;\"><a href=\"#cloneable-serializable\" aria-label=\"cloneable serializable permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cloneable, Serializable</h3>\n<p>Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.<br>\n둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다. 그 클래스를 확장하려는\n프로그래머에게 엄청난 부담을 지우기 때문이다.</p>\n<p>clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.<br>\nreadObject의 경우 하위 클래스의 상태가 미처 다 역질렬화되기 전에 재정의한 메서드부터 호출하게 된다.\nclone의 경우 하위 클래스의 clone 메서드가 복제본 상태를 (올바른 상태로) 수정하기 전에 재정의한 메서드를 호출한다.<br>\n어느 쪽이든 프로그램 오작동으로 이어질 것이다.</p>\n<p>마지막으로 Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면\n이 메서드들은 private이 아닌 protected로 선언해야 한다. private으로 선언한다면 하위 클래스에서 무시되기 때문이다. </p>\n<br/>\n<h2 id=\"그래서-결론은\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EA%B2%B0%EB%A1%A0%EC%9D%80\" aria-label=\"그래서 결론은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그래서 결론은?</h2>\n<p>클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당하다. 절대 가볍게 생각하고 정할 문제가 아니다.<br>\n추상 클래스나 인터페이스의 골격 구현처럼 상속을 허용하는 게 명백히 정당한 상황이 있고,\n불변 클래스처럼 명백히 잘못된 상황이 있다.</p>\n<p>그렇다면 그 외 일반적인 구체 클래스는 어떨까?<br>\n그대로 두면 위험하기에 해결하기 위한 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.<br>\n상속을 금지하는 방법은 두 가지다.  </p>\n<ol>\n<li>클래스를 final로 선언</li>\n<li>모든 생성자를 private or package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법.</li>\n</ol>\n<p>하지만 이 조언은 다소 논란의 여지가 있다.<br>\n그동안 수많은 프로그래머가 일반적인 구체 클래스를 상속해 계측, 통지, 동기화, 기능 제약 등을 추가해왔을 테니 말이다.</p>\n<p>핵심 기능을 정의한 인터페이스가 있고, 클래스가 그 인터페이스를 구현했다면 상속을 금지해도 개발하는데 아무런 어려움이 없을 것이다. (ex - Set, List, Map)<br>\n구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기 상당히 불편해진다.<br>\n그래서 이런 경우는 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남겨야 한다.</p>\n<br/>\n<h2 id=\"핵심-정리\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC-%EC%A0%95%EB%A6%AC\" aria-label=\"핵심 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핵심 정리</h2>\n<ul>\n<li>\n<p>상속용 클래스는 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.</p>\n<ul>\n<li>그렇지 않으면 하위 클래스를 오동작하게 만들 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>다른 사람이 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야할 수도 있다.</p>\n<ul>\n<li>이렇게 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.</li>\n</ul>\n</li>\n<li>상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.</li>\n</ul>","excerpt":"상속을 고려한 설계와 문서화란? 상속을 고려한 설계와 문서화란 정확히 무얼 뜻할까? 우선, 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 즉, 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지…","tableOfContents":"<ul>\n<li><a href=\"/effective-java-item19/#%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%84%A4%EA%B3%84%EC%99%80-%EB%AC%B8%EC%84%9C%ED%99%94%EB%9E%80\">상속을 고려한 설계와 문서화란?</a></li>\n<li><a href=\"/effective-java-item19/#%EB%AC%B8%EC%84%9C%ED%99%94%EC%9D%98-%EC%98%88\">문서화의 예</a></li>\n<li>\n<p><a href=\"/effective-java-item19/#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">주의할 점</a></p>\n<ul>\n<li><a href=\"/effective-java-item19/#cloneable-serializable\">Cloneable, Serializable</a></li>\n</ul>\n</li>\n<li><a href=\"/effective-java-item19/#%EA%B7%B8%EB%9E%98%EC%84%9C-%EA%B2%B0%EB%A1%A0%EC%9D%80\">그래서 결론은?</a></li>\n<li><a href=\"/effective-java-item19/#%ED%95%B5%EC%8B%AC-%EC%A0%95%EB%A6%AC\">핵심 정리</a></li>\n</ul>","fields":{"slug":"/effective-java-item19/"},"frontmatter":{"title":"[이펙티브 자바] 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라","date":"Feb 09, 2022","tags":["java","book"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/effective-java-item19/","series":[],"lastmod":"2022-02-09"}},"staticQueryHashes":["2027115977","694178885"]}