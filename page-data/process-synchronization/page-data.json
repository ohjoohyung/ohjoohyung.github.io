{"componentChunkName":"component---src-templates-post-tsx","path":"/process-synchronization/","result":{"data":{"markdownRemark":{"html":"<p>공유된 자원에 여러 프로세스들이 동시에 접근했을 경우 데이터 무결성에 문제가 발생할 수 있다.</p>\n<p>이러한 문제를 해결하기 위해 동기화(Synchronization) 개념이 도입되었다. 즉 공유 데이터에 대하여 동시에 접근하려 할 때, 처리 순서에 상관없이 원하는 결과를 얻기 위함이다. 이를 데이터 일관성(Data Consistency)라고 한다.</p>\n<h2 id=\"1-경쟁-상태race-condition\" style=\"position:relative;\"><a href=\"#1-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%83%9Crace-condition\" aria-label=\"1 경쟁 상태race condition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 경쟁 상태(Race Condition)</h2>\n<ul>\n<li>\n<p>공유된 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때, 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 의미한다.</p>\n<ul>\n<li>동시에 접근할 때 데이터의 일관성을 해치는 결과가 나타날 수 있음.</li>\n</ul>\n</li>\n<li>\n<p>OS에서 Race Condition이 발생하는 경우 세 가지</p>\n<ol>\n<li>\n<p>커널 안의 코드를 수행하는 중 인터럽트가 발생하는 경우</p>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/146517086-3c1f061d-0b03-4e9c-af62-2ffadab5aa6c.png\" alt=\"Untitled (92)\"></p>\n<ul>\n<li>커널 안에 있는 변수를 증가시키는 중 인터럽트가 발생하고 인터럽트 처리 함수에서 해당 변수를 감소시킬 때 변수의 결과값에 문제가 생김.</li>\n<li>사용자 프로세스는 해당 프로세스의 할당받은 메모리에만 존재할 수 있지만 커널은 서로 다른 프로세스가 공유하기 때문에 발생한다.</li>\n<li>해결법: 작업을 할 때 인터럽트가 발생하더라도 작업이 완료된 후 인터럽트가 발생하도록 처리 순서를 부여한다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스가 시스템 콜을 호출하여 커널 모드로 수행 중일 때 문맥교환이 발생하는 경우</p>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/146517090-fb8e5d52-b95e-4cd6-af76-9bc1c6354cd9.png\" alt=\"Untitled (93)\"></p>\n<ul>\n<li>사용자 프로세스가 시스템 콜을 호출하면 커널 모드로 커널 안에 존재하는 변수를 수정할 수 있다. 할당된 CPU 사용기간이 만료되면 문맥교환이 발생하는데 새롭게 CPU를 할당받은 사용자 프로세스가 이전 프로세스와 동일한 시스템 콜을 호출하여 수정하고 있던 변수에 대한 작업을 수행할 때 결과적으로 변수 값에 문제가 발생하는 경우</li>\n<li>해결법: 사용자 프로세스가 시스템 콜을 호출하여 커널 모드의 작업을 완료한 후 종료될 때 문맥교환이 발생할 수 있게 한다. 즉, 커널 모드에 있다면 CPU 제어권을 빼앗지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>여러 프로세스의 공유 메모리 내의 커널 데이터에 접근하는 경우</p>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/146517093-f43885e7-c251-4401-8e71-22bcc02f5013.png\" alt=\"Untitled (94)\"></p>\n<ul>\n<li>CPU가 여러 개인 시스템에서 공유 메모리 속 데이터를 여러 프로세스가 접근할 때 발생하는 경우</li>\n<li>해결법: 커널 안 데이터에 접근할 때 lock/unlock을 걸어 매 순간 데이터에 접근하는 프로세스는 1개로 한정한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<br/>\n<h2 id=\"2-임계영역-문제the-critical-section-problem\" style=\"position:relative;\"><a href=\"#2-%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD-%EB%AC%B8%EC%A0%9Cthe-critical-section-problem\" aria-label=\"2 임계영역 문제the critical section problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 임계영역 문제(The Critical-Section Problem)</h2>\n<ul>\n<li>\n<p>임계영역이란 OS에서 여러 프로세스가 데이터를 공유하면서 수행될 때, 각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분을 의미한다.</p>\n<ul>\n<li>공유 자원의 독점을 보장해주는 역할을 수행함.</li>\n</ul>\n</li>\n<li>\n<p>임계영역 문제를 해결하기 위한 기본 조건 세 가지</p>\n<ol>\n<li>\n<p>상호 배제(Mutual exclusion)</p>\n<ul>\n<li>어떤 프로세스가 임계영역에서 실행 중이라면, 다른 프로세스는 임계영역에 접근할 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>진행(Progress)</p>\n<ul>\n<li>임계영역에서 실행 중인 프로세스가 없다면, 다른 프로세스가 접근할 수 있도록 한다.</li>\n</ul>\n</li>\n<li>\n<p>한정된 대기(Bounded Waiting)</p>\n<ul>\n<li>다른 프로세스의 기아(Starvation)를 방지하기 위해, 한번 임계영역에 들어간 프로세스는 다음 번 임계영역에 들어갈 때 제한을 두어야 한다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<br/>\n<h2 id=\"3-피터슨의-해결안petersons-solution\" style=\"position:relative;\"><a href=\"#3-%ED%94%BC%ED%84%B0%EC%8A%A8%EC%9D%98-%ED%95%B4%EA%B2%B0%EC%95%88petersons-solution\" aria-label=\"3 피터슨의 해결안petersons solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 피터슨의 해결안(Peterson's Solution)</h2>\n<ul>\n<li>\n<p>임계영역 문제를 해결하는 기본 조건 세 가지를 충족하는 고전적 SW 기반 해결책으로 피터슨의 해결안이 있다.</p>\n<ul>\n<li>이 해결방안은 임계영역과 나머지 영역을 오가며 실행하는 두 개의 프로세스로 한정한다.</li>\n<li>\n<p>두 프로세스는 아래의 두 데이터 항목을 공유한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> turn<span class=\"token punctuation\">;</span> <span class=\"token comment\">//임계영역으로 진입할 순번</span>\n<span class=\"token keyword\">boolean</span> flag<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//프로세스가 임계영역으로 진입할 준비 되었음을 의미</span></code></pre></div>\n</li>\n<li>turn == i 이면 프로세스 Pi가 임계영역으로 실행될 수 있고 flag[i]가 true이면 Pi가 임계영역으로 진입할 준비 됨을 의미한다.</li>\n<li>\n<p>프로세스 Pi의 실행 구조</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\tflag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n\tturn <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> turn <span class=\"token operator\">==</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//critical section</span>\n\tflag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//remainder section </span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ol>\n<li>flag[i] = true에 의해 프로세스 Pi는 임계영역에 들어갈 준비가 됐다는 것을 알려주고 turn = j에 의해 프로세스 Pj가 실행될 차례라는 것을 알려줌.</li>\n<li>flag[j] = true이고 turn == j 이면 프로세스 Pj가 임계영역에 들어갈 차례이므로, Pi는 무한 루프에 들어가 기다리게 됨.</li>\n<li>프로세스 Pj가 임계영역 작업을 마치고 flag[j] = false가 되면, 프로세스 Pi는 무한루프를 빠져나와 임계영역에 들어가게 됨.</li>\n<li>프로세스 Pi가 작업 완료 후 flag[i] = false로 설정하면, 다른 프로세스가 임계영역을 사용할 수 있게 됨.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>피터슨의 해결안이 세 가지 조건을 만족하는지 확인해보자.</p>\n<ol>\n<li>\n<p>상호 배제</p>\n<ul>\n<li>flag와 turn을 이용해 한 개의 프로세스만 임계영역에 접근할 수 있도록 하였다.</li>\n</ul>\n</li>\n<li>\n<p>진행</p>\n<ul>\n<li>하나의 프로세스가 임계영역에서 빠져나오면서 flag를 false로 만들어 버리고 다른 프로세스가 접근이 가능하도록 한다.</li>\n</ul>\n</li>\n<li>\n<p>한정된 대기</p>\n<ul>\n<li>마찬가지로 하나의 프로세스가 임계영역을 빠져나오며 flag를 false로 만드니 다른 프로세스가 실행될 기회가 적어도 한번은 주어지게 된다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>피터슨의 알고리즘의 문제점은 while (flag[j] &#x26;&#x26; turn == j); 부분이다.</p>\n<ul>\n<li>이 무한루프에 CPU 자원을 쓰고 있다보니 운영체제가 CPU를 효율적으로 활용하지 못하여 문제가 발생하는데 이를 Busy waiting이라고 한다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"4-세마포어semaphore--뮤텍스mutex\" style=\"position:relative;\"><a href=\"#4-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4semaphore--%EB%AE%A4%ED%85%8D%EC%8A%A4mutex\" aria-label=\"4 세마포어semaphore  뮤텍스mutex permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 세마포어(Semaphore) &#x26; 뮤텍스(Mutex)</h2>\n<p>세마포어와 뮤텍스는 공유 자원 관리를 위해 상호 배제를 달성하는 기법들이다.</p>\n<h3 id=\"1-세마포어semaphore\" style=\"position:relative;\"><a href=\"#1-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4semaphore\" aria-label=\"1 세마포어semaphore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 세마포어(Semaphore)</h3>\n<ul>\n<li>세마포어는 멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법으로 현재 공유 자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호 배제를 달성하는 기법이다.</li>\n<li>\n<p>세마포어 P, V 연산</p>\n<ul>\n<li>P: 임계영역 들어가기 전에 수행 (프로세스 진입 여부를 자원의 개수(S)를 통해 결정)</li>\n<li>V: 임계영역에서 나올 때 수행 (자원 반납 알림, 대기 중인 프로세스를 깨우는 신호)</li>\n<li>\n<p>구현 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">P</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//critical section</span>\n<span class=\"token class-name\">V</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">procedure <span class=\"token class-name\">P</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token class-name\">S</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token keyword\">do</span> wait\n\t<span class=\"token class-name\">S</span> <span class=\"token operator\">:</span><span class=\"token operator\">=</span> <span class=\"token class-name\">S</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>\nend <span class=\"token class-name\">P</span>\n\nprocedure <span class=\"token class-name\">V</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token class-name\">S</span> <span class=\"token operator\">:</span><span class=\"token operator\">=</span> <span class=\"token class-name\">S</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>\nend <span class=\"token class-name\">V</span></code></pre></div>\n</li>\n<li>\n<p>흐름</p>\n<p>최초 S값은 1이고, 현재 해당 구역을 수행할 프로세스가 A, B 있다고 가정한다. (2개 이상도 가능)</p>\n<ol>\n<li>먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계영역에 들어감</li>\n<li>그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태</li>\n<li>A가 임계영역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨</li>\n<li>B는 P(S)에서 while문을 빠져나올 수 있고, 임계영역으로 들어가 수행함.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-뮤텍스mutual-exclusion\" style=\"position:relative;\"><a href=\"#2-%EB%AE%A4%ED%85%8D%EC%8A%A4mutual-exclusion\" aria-label=\"2 뮤텍스mutual exclusion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 뮤텍스(<strong>Mu</strong>tual Exclusion)</h3>\n<ul>\n<li>\n<p>임계영역을 가진 쓰레드들의 실행시간이 서로 겹치지 않고 단독으로 실행되게 하는 기술로 해당 접근을 조율하기 위해 lock과 unlock을 사용한다.</p>\n<ul>\n<li>lock: 현재 임계영역에 들어갈 권한을 얻어옴 (만약 다른 프로세스/쓰레드가 임계영역 수행 중이면 종료할 때까지 대기)</li>\n<li>unlock: 현재 임계영역을 모두 사용했음을 알림 (대기 중인 다른 프로세스/쓰레드가 임계영역에 진입할 수 있음)</li>\n</ul>\n</li>\n<li>\n<p>구현 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// critical section</span>\n<span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">mutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>mutex <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">}</span>\n\tmutex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tmutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<br/>\n<h3 id=\"세마포어와-뮤텍스의-차이\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"세마포어와 뮤텍스의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어와 뮤텍스의 차이</h3>\n<ul>\n<li>세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스, 쓰레드가 접근할 수 있다.\n반면, 뮤텍스는 오직 1개만의 프로세스, 쓰레드만 접근할 수 있다.</li>\n<li>현재 수행 중인 프로세스가 아닌 다른 프로세스(wait 하지 않는 프로세스)가 세마포어를 해제할 수 있다.\n반면, 뮤텍스는 lock을 획득한 프로세스가 반드시 unlock 해야 한다.</li>\n<li>세마포어는 뮤텍스가 될 수 있지만 (S = 1인 경우), 뮤텍스는 세마포어가 될 수 없다.\n뮤텍스를 상태가 0, 1 두 개인 이진 세마포어로 부르기도 한다.</li>\n</ul>\n<h3 id=\"세마포어와-뮤텍스의-단점\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"세마포어와 뮤텍스의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어와 뮤텍스의 단점</h3>\n<ul>\n<li>Busy waiting이 발생한다.</li>\n<li>\n<p>세마포어의 경우 큐 or 리스트를 활용하여 Busy waiting을 해결하는 방법이 있다고 한다.</p>\n<ul>\n<li>임계영역 진입을 위해 무한루프를 돌며 대기하는 것 대신, 프로세스를 중지시키고 큐에 넣는다.</li>\n<li>S ≤ 0 이면 waiting하는 프로세스를 중지시키고 waiting queue에 넣는다.</li>\n<li>어떤 프로세스가 임계영역에서 나오면 signal() 로 대기 큐에 있는 프로세스를 waiting queue에서 빼고 깨워 ready queue에 넣는다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"5-동기화-문제들\" style=\"position:relative;\"><a href=\"#5-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\"5 동기화 문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 동기화 문제들</h2>\n<ul>\n<li>\n<p>유한 버퍼 문제(bounded-buffer problem)</p>\n<ul>\n<li>여러 개의 프로세스를 어떻게 동기화할 것인가에 관한 고전적인 문제</li>\n<li>유한한 개수의 데이터를 임시로 보관하는 버퍼에 여러 명의 생산자들과 소비자들이 접근하는 것.</li>\n<li>생산자는 데이터가 생기면 버퍼에 저장하는데 저장할 공간이 없는 문제가 발생할 수 있음</li>\n<li>소비자는 데이터를 가져가는데 소비할 데이터가 없는 문제가 발생할 수 있다.</li>\n<li>세마포어 등으로 해결 가능</li>\n</ul>\n</li>\n<li>\n<p>Readers-Writers 문제</p>\n<ul>\n<li>여러 명의 Reader와 Writer들이 하나의 저장 공간(버퍼)을 공유하며 이를 접근할 때 발생하는 문제.</li>\n<li>세마포어 등으로 해결 가능</li>\n</ul>\n</li>\n<li>\n<p>식사하는 철학자들 문제</p>\n<ul>\n<li>여러 프로세스에게 제한된 자원을 할당하는 상황에서 발생할 수 있는 문제.</li>\n<li>각각의 철학자들이 동시에 자신의 왼쪽에 있는 젓가락을 드는 경우 Deadlock과 Starvation이 발생할 수 있음.</li>\n<li>n명이 앉을 수 있는 테이블이면 n-1명만 앉게 하여 자원의 개수를 더 많이 두거나 한 철학자가 젓가락 두 개를 모두 집을 수 있을 때만 젓가락을 집는 것을 허용하도록 하거나 누군가는 왼쪽 젓가락을 먼저 잡지 않고 오른쪽 젓가락을 먼저 잡게 하여 해결하는 방법 등이 있다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h2>\n<ul>\n<li><a href=\"https://hibee.tistory.com/297\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://hibee.tistory.com/297</a></li>\n<li><a href=\"https://dduddublog.tistory.com/25\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://dduddublog.tistory.com/25</a></li>\n</ul>","excerpt":"공유된 자원에 여러 프로세스들이 동시에 접근했을 경우 데이터 무결성에 문제가 발생할 수 있다. 이러한 문제를 해결하기 위해 동기화(Synchronization) 개념이 도입되었다. 즉 공유 데이터에 대하여 동시에 접근하려 할 때, 처리 순서에 상관없…","tableOfContents":"<ul>\n<li><a href=\"/process-synchronization/#1-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%83%9Crace-condition\">1. 경쟁 상태(Race Condition)</a></li>\n<li><a href=\"/process-synchronization/#2-%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD-%EB%AC%B8%EC%A0%9Cthe-critical-section-problem\">2. 임계영역 문제(The Critical-Section Problem)</a></li>\n<li><a href=\"/process-synchronization/#3-%ED%94%BC%ED%84%B0%EC%8A%A8%EC%9D%98-%ED%95%B4%EA%B2%B0%EC%95%88petersons-solution\">3. 피터슨의 해결안(Peterson's Solution)</a></li>\n<li>\n<p><a href=\"/process-synchronization/#4-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4semaphore--%EB%AE%A4%ED%85%8D%EC%8A%A4mutex\">4. 세마포어(Semaphore) &#x26; 뮤텍스(Mutex)</a></p>\n<ul>\n<li><a href=\"/process-synchronization/#1-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4semaphore\">1. 세마포어(Semaphore)</a></li>\n<li><a href=\"/process-synchronization/#2-%EB%AE%A4%ED%85%8D%EC%8A%A4mutual-exclusion\">2. 뮤텍스(<strong>Mu</strong>tual Exclusion)</a></li>\n<li><a href=\"/process-synchronization/#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4\">세마포어와 뮤텍스의 차이</a></li>\n<li><a href=\"/process-synchronization/#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%9D%98-%EB%8B%A8%EC%A0%90\">세마포어와 뮤텍스의 단점</a></li>\n</ul>\n</li>\n<li><a href=\"/process-synchronization/#5-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\">5. 동기화 문제들</a></li>\n<li><a href=\"/process-synchronization/#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>","fields":{"slug":"/process-synchronization/"},"frontmatter":{"title":"프로세스 동기화란?","date":"Oct 21, 2021","tags":["os"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/process-synchronization/","series":[],"lastmod":"2021-10-21"}},"staticQueryHashes":["2027115977","694178885"]}