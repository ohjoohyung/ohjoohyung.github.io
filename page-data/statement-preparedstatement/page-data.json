{"componentChunkName":"component---src-templates-post-tsx","path":"/statement-preparedstatement/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"statement\" style=\"position:relative;\"><a href=\"#statement\" aria-label=\"statement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Statement</h2>\n<p>일반적인 쿼리(Statement)를 만들어 실행하면 쿼리 분석, 컴파일, 실행 단계를 거치게 된다.<br>\n그러다보니 매번 쿼리를 실행할 때마다 반복적으로 단계를 거치게 되어 성능이 떨어질 수 있다.<br>\n뿐만 아니라 애플리케이션에서 제공해주는 라이브러리(java는 jdbc)에서 Statement를 사용해서 쿼리를 작성할 경우\n파라미터로 들어가는 곳에 \"or 1 = 1\" 과 같은 것을 삽입하여 모든 정보를 가져오거나 테이블을 통째로 날려버리는 등의\nSQL Injection 공격에 취약해지게 된다.</p>\n<br/> \n<h2 id=\"preparedstatement\" style=\"position:relative;\"><a href=\"#preparedstatement\" aria-label=\"preparedstatement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PreparedStatement</h2>\n<p>이를 위해 데이터베이스에서 PreparedStatement를 제공해준다.<br>\n앞서 말한 쿼리 분석, 컴파일 과정을 거쳐 실행 계획을 미리 만들어두고 세션 내에서 같은 쿼리를 사용할 때마다\n동일한 실행 계획을 이용할 수 있게 해준다.<br>\n또한 placeholder(? 문자)가 포함되어 있는 쿼리를 이용하면 placeholder에 값을 넣어줄 수 있는데\n이렇게 되면 미리 실행 계획이 만들어져 있어 잘못된 값이 오면 무시되므로 SQL Injection을 예방할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">prepare</span> stmt1 <span class=\"token keyword\">from</span> <span class=\"token string\">'select * from test where id = ?'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">set</span> <span class=\"token variable\">@a</span> <span class=\"token operator\">=</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">execute</span> stmt1 <span class=\"token keyword\">using</span> <span class=\"token variable\">@a</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>그렇다면 MySQL에서 PreparedStatement는 어떨까?<br>\n특히 MySQL에서 jdbc 드라이버로 제공해주는 PreparedStatement 구현체를 보니까 재밌는 사실을 알 수 있었다.</p>\n<br/>\n<h3 id=\"client-preparedstatement\" style=\"position:relative;\"><a href=\"#client-preparedstatement\" aria-label=\"client preparedstatement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Client PreparedStatement</h3>\n<p>MySQL은 4.1 버전부터 완전한 PreparedStatement를 지원하였기 때문에 그 전에는 Jdbc 드라이버를 통해\nClientPreparedStatement만 지원했다고 한다. 그렇기 때문에 PreparedStatement 흉내만 냈을 뿐이지\n실제 MySQL에서 제공하는 PreparedStatement를 사용하는 것이 아니기에 매번 쿼리 분석, 컴파일, 실행 단계가 발생한다고 한다.<br>\n오잉? 그렇다면 SQL Injection은 어떻게 막지?<br>\n이는 따로 파라미터로 들어온 값에 특정 특수문자 같은게 존재하면 \\를 추가해 escape 시켜서 보내준다.<br>\n그렇기에 SQL Injection을 막을 수 있다고 한다.</p>\n<br/>\n<h3 id=\"server-preparedstatement\" style=\"position:relative;\"><a href=\"#server-preparedstatement\" aria-label=\"server preparedstatement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server PreparedStatement</h3>\n<p>추가된 ServerPreparedStatement 객체는 실제 MySQL에서 제공하는 PreparedStatement를 사용할 수 있도록 해준다.<br>\n아래 메서드는 ServerPreparedStatement 생성자에 존재하는 serverPrepare라는 메서드인데 ServerPreparedQuery의 serverPrepare를 보면 Prepare 구문으로 만들도록 MySQL에 요청하는 걸 볼 수 있다.\n<img src=\"https://user-images.githubusercontent.com/62014888/156883610-75b7b0ba-4d30-4e1e-be67-8b1a5ea87c91.png\" alt=\"image\"></p>\n<p>그래서 실제 흐름은 Connection으로부터 PreparedStatement가 만들어질 때 MySQL에서 해당 쿼리를 이용해서 Prepare 구문을 만들고 이를 계속 사용하게 된다.<br>\n이러한 설정은 useServerPrepStmts 값에 따라 바꿀 수 있다고 한다.<br>\nuserServerPrepStmts=false이면 ClientPreparedStatement, true이면 SeverPreparedStatement를 사용할 수 있다고 하는데\n기존 코드와의 호환성을 위해 false가 default라고 한다.</p>\n<p>실제로 userServerPrepStmts=false로 하면 ClientPreparedStatement를 사용해 MySQL에서 show global status; 를 입력해 보았을 때 Prepared_stmt_count(세션 상관없이 지금 운영중인 PreparedStatement 수)가 올라가있지 않은 반면\nuserServerPrepStmts=true로 하면 ServerPreparedStatement를 사용해 올라간 모습을 볼 수 있다.</p>\n<br/>\n<h2 id=\"그렇다면-우리-플젝에서도\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%EC%9A%B0%EB%A6%AC-%ED%94%8C%EC%A0%9D%EC%97%90%EC%84%9C%EB%8F%84\" aria-label=\"그렇다면 우리 플젝에서도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다면 우리 플젝에서도?</h2>\n<p><a href=\"https://github.com/woowacourse-teams/2021-botobo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">보고 또 보고</a> 플젝에서는 jpa를 쓰는데 결국 jpa도 jdbc를 쓰기 때문에\n혹시 MariaDB에서 제공해주는 PreparedStatement를 사용하지 않고 있는건가 라는 합리적 의심이 들기 시작했다.\n테스트해본 결과 정말 사용하고 있지 않았고 userServerPrepStmts=true를 추가하니 사용된 모습을 볼 수 있었다.<br>\n그렇다면 앞으로 userServerPrepStmts=true를 추가하여 ServerPreparedStatement를 사용해야 할까?<br>\n그건 경우에 따라 다를 것 같다. 어차피 이 PreparedStatement라는게 해당 세션 내에서만 사용할 수 있고 같은 쿼리를 반복해서 사용하는 경우에 효과가 있는거라\n(<a href=\"https://kwonnam.pe.kr/wiki/database/mysql/jdbc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">심지어 테스트해보니 더 느리다는 글도 있다</a>) 적절하게 상황에 따라 테스트해보면서 사용하면 될 것 같다.</p>\n<br/>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html</a></li>\n<li><a href=\"https://www.facebook.com/cookilab/posts/544029815653831/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.facebook.com/cookilab/posts/544029815653831/</a></li>\n<li><a href=\"https://kwonnam.pe.kr/wiki/database/mysql/jdbc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://kwonnam.pe.kr/wiki/database/mysql/jdbc</a></li>\n<li><a href=\"https://2ssue.github.io/programming/HikariCP-MySQL/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://2ssue.github.io/programming/HikariCP-MySQL/</a></li>\n</ul>","excerpt":"Statement 일반적인 쿼리(Statement)를 만들어 실행하면 쿼리 분석, 컴파일, 실행 단계를 거치게 된다. 그러다보니 매번 쿼리를 실행할 때마다 반복적으로 단계를 거치게 되어 성능이 떨어질 수 있다. 뿐만 아니라 애플리케이션에서 제공해주는…","tableOfContents":"<ul>\n<li><a href=\"/statement-preparedstatement/#statement\">Statement</a></li>\n<li>\n<p><a href=\"/statement-preparedstatement/#preparedstatement\">PreparedStatement</a></p>\n<ul>\n<li><a href=\"/statement-preparedstatement/#client-preparedstatement\">Client PreparedStatement</a></li>\n<li><a href=\"/statement-preparedstatement/#server-preparedstatement\">Server PreparedStatement</a></li>\n</ul>\n</li>\n<li><a href=\"/statement-preparedstatement/#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%EC%9A%B0%EB%A6%AC-%ED%94%8C%EC%A0%9D%EC%97%90%EC%84%9C%EB%8F%84\">그렇다면 우리 플젝에서도?</a></li>\n<li><a href=\"/statement-preparedstatement/#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>","fields":{"slug":"/statement-preparedstatement/"},"frontmatter":{"title":"Statement와 PreparedStatement","date":"Mar 04, 2022","tags":["database","java"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/statement-preparedstatement/","series":[],"lastmod":"2022-03-04"}},"staticQueryHashes":["2027115977","694178885"]}