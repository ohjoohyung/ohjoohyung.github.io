{"componentChunkName":"component---src-templates-post-tsx","path":"/springboot-application/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"springbootapplication\" style=\"position:relative;\"><a href=\"#springbootapplication\" aria-label=\"springbootapplication permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@SpringBootApplication</h2>\n<ul>\n<li>우테코에서 미션을 하며 스프링 부트를 이용해서 웹 애플리케이션을 만들어보았다.</li>\n<li>스프링은 간단하게 이야기하면 스프링 빈 컨테이너를 만들어 빈 등록을 하고 필요한 객체에게 의존성 주입을 하는 방식으로 애플리케이션이 실행이 된다.</li>\n<li>근데 미션을 진행하는 동안 컨트롤러 위에 @Controller, 서비스 위에 @Service, DAO 위에 @Repository와 같은 애노테이션만 명시해주었을 뿐이고 따로 컨테이너를 생성하는 작업을 해 준 적이 없는데 어떻게 main 메서드만 실행하면 모든 작업이 이루어지는 것일까?</li>\n<li>그럼 차근차근 알아보도록 하자.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/145945185-711ac646-32f0-4a0b-ad9c-10bc7dc40bcf.png\" alt=\"Untitled (41)\"></p>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/145945190-c9d881b3-c304-4bb7-a708-504c669fe9ad.png\" alt=\"Untitled (42)\"></p>\n<ul>\n<li>일단 결론부터 이야기하자면 스프링 부트를 이용해 처음 프로젝트를 만들때 생기는 main 메서드의 run 메서드에 의해 컨테이너가 생기고 설정을 한다.</li>\n<li>그렇다면 여기서 궁금한 점이 생겼다.</li>\n<li>바로 위에 있는 @SpringBootApplication은 어떤 기능을 담당하고 있을까?</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/145945309-9f7f21e2-2391-422b-98f2-e7725ce305a3.png\" alt=\"Untitled (43)\"></p>\n<ul>\n<li>@SpringBootApplication의 위에 있는 많은 애노테이션이 있다.</li>\n<li>\n<p>하나하나 살펴보자면</p>\n<ul>\n<li>@Target - 애노테이션이 적용할 위치를 결정한다. ElementType.Type는 타입 선언시 적용한다는 뜻이다.</li>\n<li>@Retention - 애노테이션의 범위라고 할 수 있는데 어떤 시점까지 애노테이션이 영향을 미치는지 결정한다. RetetionPolicy.RUNTIME의 경우 컴파일 이후에도 JVM에 의해서 참조가 가능하다는 뜻이다.</li>\n<li>@Documented - 문서에도 애노테이션의 정보가 표현된다.</li>\n<li>@Inherited - 이 애노테이션을 선언하면 자식 클래스가 애노테이션을 상속 받을 수 있다.</li>\n<li>@SpringBootConfiguration - 스프링 부트의 설정을 나타내는 애노테이션이다. 스프링의 @Configuration을 대체하며 스프링 부트 전용 애노테이션이다. 테스트 애노테이션을 사용할 때 계속 이 애노테이션을 찾기 때문에 스프링 부트에서는 필수 애노테이션이다.</li>\n<li>@EnableAutoConfiguration - 자동 설정의 핵심 애노테이션이다. 클래스 경로에 지정된 내용을 기반으로 설정 자동화를 수행한다.</li>\n<li>@ComponentScan - 해당 패키지에서 @Component 애노테이션을 가진 Bean들을 스캔해서 등록한다. (@Configuration, @Repository, @Service, @Controller, @RestController 이 애노테이션들도 다 까보면 @Component가 존재함)</li>\n</ul>\n<p>이러하다.</p>\n</li>\n</ul>\n<br/>\n<h2 id=\"componentscan-enableautoconfiguration\" style=\"position:relative;\"><a href=\"#componentscan-enableautoconfiguration\" aria-label=\"componentscan enableautoconfiguration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ComponentScan, @EnableAutoConfiguration</h2>\n<ul>\n<li>다른 애노테이션보다 설정 관련 중요한 애노테이션은 @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration이다.</li>\n<li>@SpringBootConfiguration은 위에 적힌 대로 스프링의 @Configuration을 대체하는 기능을 하므로 넘어가고 나머지 두 애노테이션을 살펴보도록 하자.</li>\n<li>\n<p>빈 등록할 때 순서가 존재한다.\n처음에 @ComponentScan으로 등록하고 그 후 @EnableAutoConfiguration으로 추가적인 Bean을 읽어 등록한다.</p>\n<p>1단계: @ComponentScan</p>\n<p>2단계: @EnableAutoConfiguration</p>\n<p>인 셈이다.</p>\n</li>\n<li>우선 @ComponentScan이 지정된 클래스의 패키지 밑으로 component scan을 진행한다. @Componet 계열 애노테이션 (@Configuration, @Repository, @Service, @Controller, @RestController)과 @Bean 애노테이션이 붙은 method return 객체를 모두 bean으로 등록한다.</li>\n<li>다음으로 @EnableAutoConfiguration에 의해서 spring.factories 라는 파일 안에 들어있는 많은 설정들을 읽어 bean이 생성되고 스프링 부트 애플리케이션이 실행되는 것이다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/145945318-451a5ae7-f2aa-466b-8cf5-5b43c0abdec2.png\" alt=\"Untitled (44)\"></p>\n<ul>\n<li>@EnableAutoConfiguration의 경우 AutoConfigurationImportSelector를 import하고 있는데 이를 통해 spring.factories에 있는 bean들을 선택하고 등록시킬 수 있다.</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/145945323-3f9664c3-7266-4d06-a873-81d341ac4ce5.png\" alt=\"Untitled (45)\"></p>\n<ul>\n<li>그렇다면 spring.factories는 이렇게 되어있는데 여기 있는 모든 bean이 자동 등록될까?</li>\n<li>그건 아니다.\nConfigurationClassParser 클래스의 processConfigurationClass() 메서드의 shouldSkip 과정에서 Conditional 애노테이션을 찾아 조건에 부합하는지 확인하고 해당 조건을 충족하는 경우에만 등록을 진행한다고 한다.</li>\n<li>그리고 우리는 application.properties나 application.yml 파일을 이용해 설정을 하는 경우도 있다. 이때 설정을 하게 되면 spring-configuration-metadata.json 이라는 자동 설정에 사용할 프로퍼티 정의 파일에 작성한 값으로 프로퍼티를 세팅한 후 구현되어 있는 자동 설정에 값을 주입시켜준다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Caused</span> by<span class=\"token operator\">:</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span><span class=\"token class-name\">ApplicationContextException</span><span class=\"token operator\">:</span> <span class=\"token class-name\">Unable</span> <span class=\"token keyword\">to</span> <span class=\"token namespace\">start</span> <span class=\"token class-name\">ServletWebServerApplicationContext</span> due <span class=\"token keyword\">to</span> <span class=\"token namespace\">missing</span> <span class=\"token class-name\">ServletWebServerFactory</span> bean<span class=\"token punctuation\">.</span></code></pre></div>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/145945327-39d2fef0-c548-4211-882d-c8e2c0c40b21.png\" alt=\"Untitled (46)\"></p>\n<ul>\n<li>참고로 @EnableAutoConfiguration이 있어야 컨테이너에 ServletWebServerFactory bean이 등록이 되어 Web application으로 만들어준다.</li>\n<li>그래서 @EnableAutoConfiguration이 없다면 위와 같은 오류가 발생하는데 밑과 같이 WebApplicationType.NONE으로 셋팅해주면 정상적으로 실행은 된다.</li>\n</ul>\n<br/>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<ul>\n<li>스프링 부트의 경우 애노테이션을 통해 자동으로 필요한 빈들을 등록시켜준다는 것을 알게 되었다.</li>\n<li>\n<p>이러한 점을 인식하고 사용을 해야 자동 등록 기능을 끄고 수동으로 빈을 등록시켜줘야 할 때 어떤 빈들을 등록을 시켜줘야할지 빠르게 파악할 수 있을 것이다.</p>\n<ul>\n<li>대표적인 예로 Repilcation을 하기 위해 직접 Datasource를 설정해줄 때 jpa와 관련해서 어떤 빈을 등록시켜줘야 하는지와 같은 예가 있다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://camel-it.tistory.com/26\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://camel-it.tistory.com/26</a></li>\n<li><a href=\"https://duooo-story.tistory.com/52?category=882088\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://duooo-story.tistory.com/52?category=882088</a></li>\n<li><a href=\"https://rlawls1991.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EC%9B%90%EB%A6%AC-%EC%9E%90%EB%8F%99%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://rlawls1991.tistory.com/entry/스프링-부트-원리-자동설정-이해</a></li>\n<li><a href=\"https://velog.io/@adam2/SpringBoot-%EC%9E%90%EB%8F%99-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95AutoConfiguration\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://velog.io/@adam2/SpringBoot-자동-환경-설정AutoConfiguration</a></li>\n<li><a href=\"https://jdm.kr/blog/216\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://jdm.kr/blog/216</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Y11h-NUmNXI\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.youtube.com/watch?v=Y11h-NUmNXI</a></li>\n</ul>","excerpt":"@SpringBootApplication 우테코에서 미션을 하며 스프링 부트를 이용해서 웹 애플리케이션을 만들어보았다. 스프링은 간단하게 이야기하면 스프링 빈 컨테이너를 만들어 빈 등록을 하고 필요한 객체에게 의존성 주입을 하는 방식으로 애플리케이션…","tableOfContents":"<ul>\n<li><a href=\"/springboot-application/#springbootapplication\">@SpringBootApplication</a></li>\n<li><a href=\"/springboot-application/#componentscan-enableautoconfiguration\">@ComponentScan, @EnableAutoConfiguration</a></li>\n<li><a href=\"/springboot-application/#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></li>\n<li><a href=\"/springboot-application/#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>","fields":{"slug":"/springboot-application/"},"frontmatter":{"title":"@SpringBootApplication 파헤치기","date":"Jun 15, 2021","tags":["spring"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/springboot-application/","series":[],"lastmod":"2021-06-15"}},"staticQueryHashes":["2027115977","694178885"]}