{"componentChunkName":"component---src-templates-post-tsx","path":"/os-it-principle-ch9/","result":{"data":{"markdownRemark":{"html":"<p>'운영체제와 정보기술의 원리' 스터디를 진행하며 정리한 내용이다.</p>\n<hr>\n<h2 id=\"1-디스크의-구조\" style=\"position:relative;\"><a href=\"#1-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"1 디스크의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 디스크의 구조</h2>\n<p><img src=\"https://user-images.githubusercontent.com/62014888/146330069-c04dca0f-956e-4bf8-9449-6595b493e114.png\" alt=\"Untitled (89)\"></p>\n<ul>\n<li>\n<p>디스크 외부에서는 디스크를 일정한 크기의 저장공간들로 이루어진 1차원 배열처럼 취급하게 되는데 이 일정한 크기의 저장공간을 논리블록(logical block)이라고 한다.</p>\n<ul>\n<li>디스크에 데이터가 저장될 때에는 논리블록 단위로 저장</li>\n<li>디스크 외부로 입출력이 일어날 때에도 논리블록 단위로 전송</li>\n<li>논리블록에 저장된 데이터를 접근하기 위해서는 배열을 접근하는 것처럼 해당 블록의 인덱스 번호를 전달해야 함.</li>\n<li>논리블록이 저장되는 디스크 내의 물리적 위치를 섹터(sector)라고 부르고 논리블록 하나가 섹터 하나와 1 대 1로 매핑되어 저장되는 것.</li>\n</ul>\n</li>\n<li>디스크는 마그네틱의 원판으로 구성되어 있는데 각각의 원판은 트랙(track)으로 구성되고 각 트렉은 섹터로 나뉨.</li>\n<li>여러 개의 원판에서 상대적 위치가 동일한 트랙의 집합을 실린더(cylinder)라 부름.</li>\n<li>디스크에 데이터를 읽고 쓰기 위해서는 암(arm)이 해당 섹터가 위치한 실린더로 이동.</li>\n</ul>\n<h2 id=\"2-디스크-스케줄링\" style=\"position:relative;\"><a href=\"#2-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"2 디스크 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 디스크 스케줄링</h2>\n<ul>\n<li>\n<p>디스크에 대한 접근시간(access time)은 몇 가지로 구분된다.</p>\n<ul>\n<li>탐색시간(seek time) - 디스크 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간.</li>\n<li>회전지연시간(rotational latency) - 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간</li>\n<li>전송시간(transfer time) - 해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는데 소요되는 시간.</li>\n</ul>\n</li>\n<li>\n<p>디스크 입출력의 효율을 높이기 위해서는 디스크 입출력에 소요되는 접근시간을 최소화해야 함.</p>\n<ul>\n<li>회전지연시간과 전송시간은 상대적인 수치가 작을 뿐 아니라 운영체제 입장에서 통제하기 힘든 부분.</li>\n<li>따라서 탐색시간을 줄이기 위해 헤드의 움직임을 최소화하는 스케줄링 작업을 함.</li>\n</ul>\n</li>\n<li>\n<p>디스크 스케줄링(disk scheduling)이란 효율적인 디스크 입출력을 위해 여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떠한 순서로 처리할 것인지 결정하는 메커니즘을 뜻함.</p>\n<ul>\n<li>가장 중요한 목표는 디스크 헤드의 이동거리를 줄이는 것.</li>\n</ul>\n</li>\n<li>\n<p>FCFS 스케줄링</p>\n<ul>\n<li>FCFS(First Come First Served) 스케줄링은 디스크에 먼저 들어온 요청을 먼저 처리하는 방식.</li>\n<li>FCFS 스케줄링이 적용되는 디스크에서 최악의 경우 입출력 요청이 디스크의 한쪽 끝과 반대쪽 끝에 번갈아 도착한다면 헤드는 디스크를 계속 왕복하며 일을 처리해야 하므로 탐색시간이 매우 비효율적으로 늘어나는 결과를 초래함.</li>\n</ul>\n</li>\n<li>\n<p>SSTF 스케줄링</p>\n<ul>\n<li>SSTF(Shortest Seek Time First) 스케줄링은 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘.</li>\n<li>\n<p>헤드의 이동거리를 줄여 디스크 입출력의 효율성을 증가시키지만, 자칫 기아 현상(starvation)을 발생시킬 수 있음.</p>\n<ul>\n<li>현재 헤드의 위치로부터 가까운 곳에서 지속적인 요청이 들어올 경우 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>SCAN 알고리즘</p>\n<ul>\n<li>\n<p>SCAN 알고리즘은 헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리함.</p>\n<ul>\n<li>즉 디스크의 어떠한 위치에 요청이 들어오는가와 상관없이 헤드는 정해진 방향으로 이동하며 길목에 있는 요청들을 처리하며 지나가는 것.</li>\n</ul>\n</li>\n<li>엘리베이터에서 사용하는 스케줄링 알고리즘과 유사하여 SCAN 알고리즘을 엘레베이터 스케줄링 알고리즘이라고도 부름.</li>\n<li>SCAN 알고리즘에서는 FCFS처럼 불필요한 헤드의 이동이 발생하거나 SSTF처럼 일부 지역이 지나치게 오래 기다리는 현상이 발생하지 않는 효율성과 형평성을 모두 만족하는 알고리즘.</li>\n<li>\n<p>다만 모든 실린더 위치의 기다리는 시간이 공평한 것은 아님.</p>\n<ul>\n<li>제일 안쪽이나 제일 바깥쪽 위치보다는 가운데 위치가 기다리는 평균시간이 더 짧음.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>C-SCAN 알고리즘</p>\n<ul>\n<li>C-SCAN(Circular-SCAN) 알고리즘은 SCAN처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리함.</li>\n<li>SCAN과는 달리 헤드가 다른 쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고 곧바로 출발점으로 다시 이동만 함.</li>\n<li>이 방식은 각 실린더 위치에 대해 SCAN보다 좀 더 균일한 탐색시간을 제공함.</li>\n</ul>\n</li>\n<li>\n<p>LOOK과 C-LOOK 알고리즘</p>\n<ul>\n<li>LOOK 알고리즘은 헤드가 한쪽 방향으로 이동하다가 그 방향에 더 이상 대기 중인 요청이 없으면 헤드의 이동 방향을 즉시 반대로 바꾸는 스케줄링 방식.</li>\n<li>C-LOOK 알고리즘은 전방에 요청이 없을 때 방향을 바꾼다는 측면에서는 LOOK과 유사하며, 한쪽 방향으로 이동할 때에만 요청을 처리한다는 점에서 C-SCAN과 유사함.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-다중-디스크-환경에서의-스케줄링\" style=\"position:relative;\"><a href=\"#3-%EB%8B%A4%EC%A4%91-%EB%94%94%EC%8A%A4%ED%81%AC-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"3 다중 디스크 환경에서의 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 다중 디스크 환경에서의 스케줄링</h2>\n<ul>\n<li>다중 디스크를 사용하면 시스템의 성능과 신뢰성을 동시에 향상시킬 수 있음.</li>\n<li>같은 데이터가 저장되어 있는 여러 개의 디스크 중 어느 디스크에서 요청을 처리할지 결정하는 스케줄링 문제가 발생함.</li>\n<li>다중 디스크에서의 스케줄링은 작업을 수행할 디스크를 결정하는 문제까지 포함함.</li>\n<li>\n<p>이러한 시스템에서는 스케줄링의 목표에 따라 요청을 처리할 디스크를 결정하는 기준이 달라짐.</p>\n<ul>\n<li>탐색시간을 줄이는 것이 목표라면 여러 디스크 중에서 헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크를 선택하는 방법을 사용</li>\n<li>좀 더 거시적인 관점에서는 각 디스크 간의 부하균형(load balancing)을 이루도록 스케줄링하는 것이 중요</li>\n</ul>\n</li>\n<li>\n<p>최근에는 전력 소모를 줄이는 것이 또 다른 중요한 목표로 인식되고 있음</p>\n<ul>\n<li>일부 디스크에 요청을 집중시키고 나머지 디스크는 회전을 정지시키는 것이 효과적.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-디스크의-저전력-관리\" style=\"position:relative;\"><a href=\"#4-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%EC%A0%80%EC%A0%84%EB%A0%A5-%EA%B4%80%EB%A6%AC\" aria-label=\"4 디스크의 저전력 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 디스크의 저전력 관리</h2>\n<ol>\n<li>\n<p>비활성화 기법</p>\n<ul>\n<li>\n<p>디스크의 상태는 전력 소모를 기준으로 크게 네 가지로 나눌 수 있음</p>\n<ul>\n<li>활동(active) 상태 - 현재 헤드가 데이터를 읽거나 쓰고 있는 상태</li>\n<li>공회전(idle) 상태 - 디스크가 회전 중이지만 데이터를 읽거나 쓰지는 않는 상태</li>\n<li>준비(standby) 상태 - 디스크가 회전하지 않지만 인터페이스가 활성화된 상태</li>\n<li>휴면(sleep) 상태 - 디스크가 회전하지 않고 인터페이스도 비활성화된 상태</li>\n</ul>\n</li>\n<li>디스크가 회전 중인 상태를 활성 상태라고 부르고, 디스크가 정지한 상태를 비활성 상태라고 부르면 활성 상태보다 비활성 상태에서 전력 소모가 적으며 요청이 없을 경우 디스크를 정지시키는 것이 전력 절감 측면에서 효과적.</li>\n<li>\n<p>다만 각 상태로 전환할 때는 부가적인 전력 및 시간이 소모됨.</p>\n<ul>\n<li>따라서 후속 요청까지의 시간 간격이 일정 시간(break-even time) 이상일 경우에만 디스크의 회전을 정지시키는 것이 전력 소모를 절감하는 데 효과적.</li>\n<li>비활성화할 지점을 결정하기 위해 미래의 요청이 도착하는 시점과 간격을 정확히 예측하는 것이 중요함.</li>\n</ul>\n</li>\n<li>\n<p>디스크를 비활성화하는 시점을 결정하는 방법으로는 세 가지가 있음</p>\n<ul>\n<li>시간기반(timeout based) 기법 - 일정 시간 동안 디스크가 공회전 상태이면 장치를 정지시켰다가, 다시 요청이 왔을 때 디스크를 활성화함.</li>\n<li>예측기반(prediction based) 기법 - 과거 요청을 관찰하여 다음 공회전 구간의 길이를 예측한 후 디스크를 비활성화할 시점을 결정함.</li>\n<li>확률기반(stochastic based) 기법 - 디바이스의 상태변경 시간 간격을 구하기 위해 확률분포를 통해 요청을 모델링하고 마르코프 체인 등과 같은 통계적 모델을 이용함.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>회전속도 조절 기법</p>\n<ul>\n<li>디스크의 전력 소모를 줄이기 위한 방법으로 최근에는 디스크의 회전속도(Rotations Per Minute: RPM)를 가변적으로 조절하는 기법이 제안되었음.</li>\n<li>디바이스 스준에서 이와 같은 기능이 지원됨에 따라 운영체제에서는 전력 소모를 최소화하기 위해 디스크의 회전속도를 관리하는 지능형 전력 관리 기법에 대한 연구가 이루어지고 있음.</li>\n</ul>\n</li>\n<li>\n<p>디스크의 데이터 배치 기법</p>\n<ul>\n<li>디스크의 용량은 매년 빠른 속도로 증가하고 있으나 디스크의 접근 속도는 기계적 메커니즘으로 인해 그다지 큰 발전이 없는 실정임.</li>\n<li>대부분의 컴퓨터 시스템에서 디스크의 53% 이상이 빈 공간 상태로 남아 있다는 점에 착안해, 디스크 내에 데이터의 복제본을 많이 만들어 헤드 위치에서 가까운 복제본을 접근하도록 함으로써 빠른 응답시간과 전력 소모량 절감을 얻는 FS2 파일 시스템을 제안한 팀도 있음.</li>\n</ul>\n</li>\n<li>\n<p>버퍼캐싱 및 사전인출 기법</p>\n<ul>\n<li>미래에 요청될 데이터를 미리 알거나 어느 정도 예측할 수 있다면 디스크가 활성 상태일 때 헤드 위치로부터 가까운 데이터를 사전인출(prefetching) 함으로써 향후 디스크의 비활성화 가능성을 높여 전력 소모를 줄일 수 있음.</li>\n<li>데드라인을 꼭 지켜야 하는 요청이 아닌 경우, 디스크의 활성 상태 여부에 따라 요청을 최대한 지연시키는 방식으로 전력 소모를 줄일 수 있음.</li>\n</ul>\n</li>\n<li>\n<p>쓰기전략을 통한 저전력 디스크 기법</p>\n<ul>\n<li>저장장치의 데이터에 대한 쓰기전략을 통해 전력 소모를 줄이는 기법도 제안되고 있음.</li>\n<li>디스크가 활성 상태로 돌아왔을 때 쓰는 방식 또는 대상 디스크가 활성 상태가 아니면 일단 블록들을 로그 디스크에 썼다가 디스크가 활성 상태로 돌아왔을 때 디스크에 쓰기연산을 수행하는 방식 등이 있음.</li>\n</ul>\n</li>\n</ol>","excerpt":"'운영체제와 정보기술의 원리' 스터디를 진행하며 정리한 내용이다. 1. 디스크의 구조 Untitled (89) 디스크 외부에서는 디스크를 일정한 크기의 저장공간들로 이루어진 1차원 배열처럼 취급하게 되는데 이 일정한 크기의 저장공간을 논리블록(log…","tableOfContents":"<ul>\n<li><a href=\"/os-it-principle-ch9/#1-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%EA%B5%AC%EC%A1%B0\">1. 디스크의 구조</a></li>\n<li><a href=\"/os-it-principle-ch9/#2-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">2. 디스크 스케줄링</a></li>\n<li><a href=\"/os-it-principle-ch9/#3-%EB%8B%A4%EC%A4%91-%EB%94%94%EC%8A%A4%ED%81%AC-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">3. 다중 디스크 환경에서의 스케줄링</a></li>\n<li><a href=\"/os-it-principle-ch9/#4-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%EC%A0%80%EC%A0%84%EB%A0%A5-%EA%B4%80%EB%A6%AC\">4. 디스크의 저전력 관리</a></li>\n</ul>","fields":{"slug":"/os-it-principle-ch9/"},"frontmatter":{"title":"[운영체제와 정보기술의 원리] 9. 디스크 관리","date":"Oct 18, 2021","tags":["os","book","os-it-principle"],"keywords":["Dev.Oh","JooHyung Oh"],"update":"Jan 01, 0001"}}},"pageContext":{"slug":"/os-it-principle-ch9/","series":[],"lastmod":"2021-10-18"}},"staticQueryHashes":["2027115977","694178885"]}