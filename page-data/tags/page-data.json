{"componentChunkName":"component---src-pages-tags-tsx","path":"/tags/","result":{"data":{"allMarkdownRemark":{"group":[{"fieldValue":"book","totalCount":27,"edges":[{"node":{"excerpt":"트랜잭션은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다. 잠금은 동시성…","fields":{"slug":"/real-mysql-ch5/"},"frontmatter":{"date":"Dec 24, 2021","update":"Jan 01, 0001","title":"[Real MySQL] 5. 트랜잭션과 잠금","tags":["database","book"]}}},{"node":{"excerpt":"compareTo, Comparable? compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다. Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서(natural order)가 있음을 뜻한다.…","fields":{"slug":"/effective-java-item14/"},"frontmatter":{"date":"Dec 21, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 14. Comparable을 구현할지 고려하라","tags":["java","book"]}}},{"node":{"excerpt":"Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만, 아쉽게도 의도한 목적을 제대로 이루지 못했음. 가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라…","fields":{"slug":"/effective-java-item13/"},"frontmatter":{"date":"Dec 20, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 13. clone 재정의는 주의해서 진행하라","tags":["java","book"]}}},{"node":{"excerpt":"toString을 재정의하자. Object의 기본 toString 메서드는 PhoneNumber@abddb처럼 단순히 클래스_이름@16진수로_표시한_해시코드를 반환할 뿐임. toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 …","fields":{"slug":"/effective-java-item12/"},"frontmatter":{"date":"Dec 19, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 12. toString을 항상 재정의하라","tags":["java","book"]}}},{"node":{"excerpt":"hashCode 재정의 equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를…","fields":{"slug":"/effective-java-item11/"},"frontmatter":{"date":"Dec 19, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 11. equals를 재정의하려거든 hashCode도 재정의하라","tags":["java","book"]}}},{"node":{"excerpt":"equals를 재정의하지 않는 상황 각 인스턴스가 본질적으로 고유하다. 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스. Thread가 좋은 예. 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다. 상위 클래스…","fields":{"slug":"/effective-java-item10/"},"frontmatter":{"date":"Dec 18, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라","tags":["java","book"]}}},{"node":{"excerpt":"자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, java.sql.Connection 등이 좋은 예. 자원 닫기는 클라이언트가 놓치기 쉬워서 예측할 수 없는 성능 문제로 …","fields":{"slug":"/effective-java-item9/"},"frontmatter":{"date":"Dec 17, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 9. try-finally보다는 try-with-resources를 사용하라","tags":["java","book"]}}},{"node":{"excerpt":"자바는 두 가지 객체 소멸자를 제공함. finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 함. 자바 9에서는 deprecated API로 지정하고 cleaner…","fields":{"slug":"/effective-java-item8/"},"frontmatter":{"date":"Dec 16, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 8. finalizer와 cleaner 사용을 피하라","tags":["java","book"]}}},{"node":{"excerpt":"자바와 같이 가비지 컬렉터를 갖춘 언어를 사용하기에 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 절대 사실이 아니다. 이 스택을 사용하는 프로그램을 오래 실행하다 보면 '메모리 누수'로 점차 가비지 컬렉션 활동과 메모리 …","fields":{"slug":"/effective-java-item7/"},"frontmatter":{"date":"Dec 16, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 7. 다 쓴 객체 참조를 해제하라","tags":["java","book"]}}},{"node":{"excerpt":"똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다. 재사용은 빠르고 세련됨. 특히 불변 객체는 언제든 재사용할 수 있다. 첫번째 코드는 String 인스턴스를 새로 만들게 되어 생성자에 넘겨진 \"bikini\" 자체…","fields":{"slug":"/effective-java-item6/"},"frontmatter":{"date":"Dec 15, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 6. 불필요한 객체 생성을 피하라","tags":["java","book"]}}},{"node":{"excerpt":"사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다. 대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다. 이 조건을 만족하는 간단한 패턴이 있으니, 바로 인스…","fields":{"slug":"/effective-java-item5/"},"frontmatter":{"date":"Dec 15, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","tags":["java","book"]}}},{"node":{"excerpt":"정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것. 객체 지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기에 그리 곱게 보이지는 않지만, 분명 나름의 쓰임새가 있음. 그렇다면 정적 메서드와 정적 필드를 사용하는 것이 왜 객체…","fields":{"slug":"/effective-java-item4/"},"frontmatter":{"date":"Dec 14, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라","tags":["java","book"]}}},{"node":{"excerpt":"싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다. 전형적인 예 - 함수와 같은 무상태 객체나 설계상 유일하게 하는 시스템 컴포넌트 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. 인터페이스를 구…","fields":{"slug":"/effective-java-item3/"},"frontmatter":{"date":"Dec 14, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라","tags":["java","book"]}}},{"node":{"excerpt":"정적 팩터리와 생성자에는 똑같은 제약이 있다. 선택적 매개변수가 많을때 적절히 대응하기 어렵다는 점! 필드에 변수가 많이 있을 때 이런 클래스용 생성자 혹은 정적 팩터리는 어떤 모습일까? 3가지 방법을 사용한 모습이 있겠다. 점층적 생성자 패턴(te…","fields":{"slug":"/effective-java-item2/"},"frontmatter":{"date":"Dec 13, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 2. 생성자에 매개변수가 많다면 빌더를 고려하라","tags":["java","book"]}}},{"node":{"excerpt":"클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자다. 클래스는 생성자와 별도로 정적 팩터리 메서드를 제공할 수 있다. 정적 팩터리 메서드는 클래스의 인스턴스를 반환하는 단순한 정적 메서드를 뜻한다. 정적 팩터리 메서드는 디자인…","fields":{"slug":"/effective-java-item1/"},"frontmatter":{"date":"Dec 13, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라","tags":["java","book"]}}},{"node":{"excerpt":"1. 디스크의 구조 Untitled (89) 디스크 외부에서는 디스크를 일정한 크기의 저장공간들로 이루어진 1차원 배열처럼 취급하게 되는데 이 일정한 크기의 저장공간을 논리블록(logical block)이라고 한다. 디스크에 데이터가 저장될 때에는 …","fields":{"slug":"/os-it-principle-ch9/"},"frontmatter":{"date":"Oct 18, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 9. 디스크 관리","tags":["os","book"]}}},{"node":{"excerpt":"시분할 환경에서는 한정된 메모리 공간을 여러 프로그램이 조금씩 나누어서 사용하다보니 운영체제는 어떤 프로그램에게 어느 정도의 메모리를 할당할 것인가 하는 문제에 당면하게 됨. 운영체제는 모든 프로그램들에게 공평하게 메모리를 할당하기보다는 몇몇 프로그…","fields":{"slug":"/os-it-principle-ch8/"},"frontmatter":{"date":"Oct 17, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 8. 가상메모리","tags":["os","book"]}}},{"node":{"excerpt":"컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소 체계를 사용하면 2의 32제곱 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다. 효율적인 운영을 위해 보통 4KB(= 2의 12제곱 byte) 단위로 묶어서 페이지…","fields":{"slug":"/os-it-principle-ch7/"},"frontmatter":{"date":"Oct 16, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 7. 메모리 관리","tags":["os","book"]}}},{"node":{"excerpt":"CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치. 일반적으로 한 시스템 내에 하나씩밖에 없으므로 시분할 환경에서 매우 효율적으로 관리되어야 하는 자원. 기계어 명령은 크게 CPU 내에서 수행되는 명령, 메모리 접근을 필요로…","fields":{"slug":"/os-it-principle-ch6/"},"frontmatter":{"date":"Oct 15, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 6. CPU 스케줄링","tags":["os","book"]}}},{"node":{"excerpt":"1. 프로세스의 개념 프로세스(process)란 실행 중인 프로그램(program in execution)을 뜻한다. 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스가 되며, 프로세스는 CPU를 획득해 자신의…","fields":{"slug":"/os-it-principle-ch5/"},"frontmatter":{"date":"Oct 14, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 5. 프로세스 관리","tags":["os","book"]}}},{"node":{"excerpt":"1. 프로그램의 구조와 인터럽트 컴퓨터 프로그램은 어떠한 프로그래밍 언어로 작성되었든 그 내부 구조는 함수들로 구성된다. 프로그램의 주소 영역은 크게 코드(code), 데이터(data), 스택(stack) 영역으로 구분됨. 코드 영역 - 우리가 작성…","fields":{"slug":"/os-it-principle-ch4/"},"frontmatter":{"date":"Oct 13, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 4. 프로그램의 구조와 실행","tags":["os","book"]}}},{"node":{"excerpt":"1. 컴퓨터 시스템의 구조 컴퓨터 내부장치인 CPU, 메모리와 컴퓨터 외부장치인 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등으로 구성된다. 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 그 결과를 외부장치로 다시 …","fields":{"slug":"/os-it-principle-ch3/"},"frontmatter":{"date":"Oct 12, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 3. 컴퓨터 시스템의 동작 원리","tags":["os","book"]}}},{"node":{"excerpt":"1. 운영체제의 정의 운영체제란 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어 Untitled (67) 운영체제에 시스템이라는 용어가 사용된 것은 하드웨어가 운영체제와 한 몸이 되어야만 사용자에게 쓰일 수 있는 진정한 컴퓨터 시스템이 되기 때문. …","fields":{"slug":"/os-it-principle-ch2/"},"frontmatter":{"date":"Oct 11, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 2. 운영체제의 개요","tags":["os","book"]}}},{"node":{"excerpt":"01 서버의 개요 클라이언트와 서버의 차이점 공통점 네트워크에 관한 부분, 즉 LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능은 클라이언트와 조금도 다르지 않다. 차이점 서버 머신은 용도에 따라 다양한 종류가 있고, 하드웨어나 OS…","fields":{"slug":"/1per-network-ch6/"},"frontmatter":{"date":"Oct 08, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 6장","tags":["network","book"]}}},{"node":{"excerpt":"01 웹 서버의 설치 장소 사내에 웹 서버를 설치하는 경우 인터넷을 빠져나와 서버에 도착할 때까지의 여정은 서버의 설치 장소에 따라 다름. Untitled - 2021-12-22T173836 683 라우터에서 직접 연결하는 경우 이전에는 이런 형태로…","fields":{"slug":"/1per-network-ch5/"},"frontmatter":{"date":"Oct 05, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 5장","tags":["network","book"]}}},{"node":{"excerpt":"01 케이블과 리피터, 허브 속을 신호가 흘러간다 하나하나의 패킷이 독립된 것으로 동작한다. 중계 동작은 패킷의 헤더에 기록된 제어 정보와 중계 장치의 내부에 있는 중계 대상을 등록한 표로 목적지를 판단하고 목적지에 가까워지도록 하여 패킷을 중계한다…","fields":{"slug":"/1per-network-ch3/"},"frontmatter":{"date":"Oct 01, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 3장","tags":["network","book"]}}},{"node":{"excerpt":"01 HTTP 리퀘스트 메시지를 작성한다. 탐험의 여행은 URL 입력부터 시작한다. URL은 http: 뿐만 아니라 ftp:, file:, mailto: 로 시작하는 것 등 여러 가지가 있다. 브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 클…","fields":{"slug":"/1per-network-ch1/"},"frontmatter":{"date":"Sep 25, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 1장","tags":["network","book"]}}}]},{"fieldValue":"cache","totalCount":2,"edges":[{"node":{"excerpt":"무엇을 캐싱했을까? 보고 또 보고 에서는 문제집 검색 기능을 제공한다. 검색 기능이 고도화되면서 키워드로 검색된 문제집 결과에 유저, 태그로 필터해주는 기능도 추가되었다. 이렇게만 들었을 때는 '검색된 문제집들의 유저와 태그 리스트가 있을테니 이를 …","fields":{"slug":"/redis-cache/"},"frontmatter":{"date":"Dec 04, 2021","update":"Jan 01, 0001","title":"보또보에서 캐싱을 통해 성능 개선하기","tags":["redis","cache"]}}},{"node":{"excerpt":"캐싱이라는 용어는 프로그래밍에서 자주 등장하게 된다.\n캐싱이란 '성능 향상을 위해 사용이 많은 데이터를 별도 공간에 일시적으로 저장하여 필요할 때마다 데이터를 가져오는 기술'이다.\n메모리, 네트워크 등 다양한 곳에서 사용하게 되는데 Spring에서도…","fields":{"slug":"/spring-cache/"},"frontmatter":{"date":"Dec 04, 2021","update":"Jan 01, 0001","title":"Spring Cache 살펴보기","tags":["spring","cache"]}}}]},{"fieldValue":"database","totalCount":5,"edges":[{"node":{"excerpt":"트랜잭션은 작업의 완전성을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다. 잠금은 동시성…","fields":{"slug":"/real-mysql-ch5/"},"frontmatter":{"date":"Dec 24, 2021","update":"Jan 01, 0001","title":"[Real MySQL] 5. 트랜잭션과 잠금","tags":["database","book"]}}},{"node":{"excerpt":"Cross Join? JPA 빌더인 QueryDSL을 사용하다보면 Join 쿼리 작성할 때 주의하지 않으면 Cross Join이 발생한다고 한다. 예전에 이동욱님 글에서 한번 본 적이 있었는데 당시에는 QueryDSL을 사용하고 있지 않던 터라 그냥…","fields":{"slug":"/cross-join/"},"frontmatter":{"date":"Sep 30, 2021","update":"Jan 01, 0001","title":"Cross Join 살펴보기","tags":["database","join"]}}},{"node":{"excerpt":"Master & Slave DB 설치 Master DB 설정 아래 파일에서 설정 수정 Untitled (55)\nUntitled (56) mariadb 재시작 master db의 File과 Position 값을 slave db에 설정해야함 Untitl…","fields":{"slug":"/replication/"},"frontmatter":{"date":"Sep 29, 2021","update":"Jan 01, 0001","title":"DB Replication 따라해보기","tags":["database","replication"]}}},{"node":{"excerpt":"ANSI SQL DBMS(Oracle, MySQL 등등)들에서 각기 다른 SQL을 사용하므로 미국 표준 협회(American National Standards Institute)에서 이를 표준화하여 표준 SQL문을 정립시켜 놓은 것. ANSI SQL…","fields":{"slug":"/join/"},"frontmatter":{"date":"Sep 12, 2021","update":"Jan 01, 0001","title":"DB Join 종류 알아보기","tags":["database"]}}},{"node":{"excerpt":"Flyway란? Flyway란 DataBase Migration Tool로 DataBase Migration을 손쉽게 해결해주는 도구 중 하나이다. 그렇다면 DataBase Migration은 무엇일까? DataBase Migration 마이그레이션…","fields":{"slug":"/flyway/"},"frontmatter":{"date":"Aug 25, 2021","update":"Jan 01, 0001","title":"보또보 Flyway 도입기","tags":["flyway","database"]}}}]},{"fieldValue":"flyway","totalCount":1,"edges":[{"node":{"excerpt":"Flyway란? Flyway란 DataBase Migration Tool로 DataBase Migration을 손쉽게 해결해주는 도구 중 하나이다. 그렇다면 DataBase Migration은 무엇일까? DataBase Migration 마이그레이션…","fields":{"slug":"/flyway/"},"frontmatter":{"date":"Aug 25, 2021","update":"Jan 01, 0001","title":"보또보 Flyway 도입기","tags":["flyway","database"]}}}]},{"fieldValue":"java","totalCount":18,"edges":[{"node":{"excerpt":"compareTo, Comparable? compareTo는 단순 동치성 비교에 더해 순서까지 비교할 수 있으며, 제네릭하다. Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 자연적인 순서(natural order)가 있음을 뜻한다.…","fields":{"slug":"/effective-java-item14/"},"frontmatter":{"date":"Dec 21, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 14. Comparable을 구현할지 고려하라","tags":["java","book"]}}},{"node":{"excerpt":"Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만, 아쉽게도 의도한 목적을 제대로 이루지 못했음. 가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable이 아닌 Object이고, 그마저도 protected라…","fields":{"slug":"/effective-java-item13/"},"frontmatter":{"date":"Dec 20, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 13. clone 재정의는 주의해서 진행하라","tags":["java","book"]}}},{"node":{"excerpt":"toString을 재정의하자. Object의 기본 toString 메서드는 PhoneNumber@abddb처럼 단순히 클래스_이름@16진수로_표시한_해시코드를 반환할 뿐임. toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 …","fields":{"slug":"/effective-java-item12/"},"frontmatter":{"date":"Dec 19, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 12. toString을 항상 재정의하라","tags":["java","book"]}}},{"node":{"excerpt":"hashCode 재정의 equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를…","fields":{"slug":"/effective-java-item11/"},"frontmatter":{"date":"Dec 19, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 11. equals를 재정의하려거든 hashCode도 재정의하라","tags":["java","book"]}}},{"node":{"excerpt":"equals를 재정의하지 않는 상황 각 인스턴스가 본질적으로 고유하다. 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스. Thread가 좋은 예. 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다. 상위 클래스…","fields":{"slug":"/effective-java-item10/"},"frontmatter":{"date":"Dec 18, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 10. equals는 일반 규약을 지켜 재정의하라","tags":["java","book"]}}},{"node":{"excerpt":"자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다. InputStream, OutputStream, java.sql.Connection 등이 좋은 예. 자원 닫기는 클라이언트가 놓치기 쉬워서 예측할 수 없는 성능 문제로 …","fields":{"slug":"/effective-java-item9/"},"frontmatter":{"date":"Dec 17, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 9. try-finally보다는 try-with-resources를 사용하라","tags":["java","book"]}}},{"node":{"excerpt":"자바는 두 가지 객체 소멸자를 제공함. finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 오동작, 낮은 성능, 이식성 문제의 원인이 되기도 함. 자바 9에서는 deprecated API로 지정하고 cleaner…","fields":{"slug":"/effective-java-item8/"},"frontmatter":{"date":"Dec 16, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 8. finalizer와 cleaner 사용을 피하라","tags":["java","book"]}}},{"node":{"excerpt":"자바와 같이 가비지 컬렉터를 갖춘 언어를 사용하기에 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 절대 사실이 아니다. 이 스택을 사용하는 프로그램을 오래 실행하다 보면 '메모리 누수'로 점차 가비지 컬렉션 활동과 메모리 …","fields":{"slug":"/effective-java-item7/"},"frontmatter":{"date":"Dec 16, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 7. 다 쓴 객체 참조를 해제하라","tags":["java","book"]}}},{"node":{"excerpt":"똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다. 재사용은 빠르고 세련됨. 특히 불변 객체는 언제든 재사용할 수 있다. 첫번째 코드는 String 인스턴스를 새로 만들게 되어 생성자에 넘겨진 \"bikini\" 자체…","fields":{"slug":"/effective-java-item6/"},"frontmatter":{"date":"Dec 15, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 6. 불필요한 객체 생성을 피하라","tags":["java","book"]}}},{"node":{"excerpt":"사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다. 대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다. 이 조건을 만족하는 간단한 패턴이 있으니, 바로 인스…","fields":{"slug":"/effective-java-item5/"},"frontmatter":{"date":"Dec 15, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라","tags":["java","book"]}}},{"node":{"excerpt":"정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것. 객체 지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기에 그리 곱게 보이지는 않지만, 분명 나름의 쓰임새가 있음. 그렇다면 정적 메서드와 정적 필드를 사용하는 것이 왜 객체…","fields":{"slug":"/effective-java-item4/"},"frontmatter":{"date":"Dec 14, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 4. 인스턴스화를 막으려거든 private 생성자를 사용하라","tags":["java","book"]}}},{"node":{"excerpt":"싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다. 전형적인 예 - 함수와 같은 무상태 객체나 설계상 유일하게 하는 시스템 컴포넌트 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. 인터페이스를 구…","fields":{"slug":"/effective-java-item3/"},"frontmatter":{"date":"Dec 14, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라","tags":["java","book"]}}},{"node":{"excerpt":"정적 팩터리와 생성자에는 똑같은 제약이 있다. 선택적 매개변수가 많을때 적절히 대응하기 어렵다는 점! 필드에 변수가 많이 있을 때 이런 클래스용 생성자 혹은 정적 팩터리는 어떤 모습일까? 3가지 방법을 사용한 모습이 있겠다. 점층적 생성자 패턴(te…","fields":{"slug":"/effective-java-item2/"},"frontmatter":{"date":"Dec 13, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 2. 생성자에 매개변수가 많다면 빌더를 고려하라","tags":["java","book"]}}},{"node":{"excerpt":"클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자다. 클래스는 생성자와 별도로 정적 팩터리 메서드를 제공할 수 있다. 정적 팩터리 메서드는 클래스의 인스턴스를 반환하는 단순한 정적 메서드를 뜻한다. 정적 팩터리 메서드는 디자인…","fields":{"slug":"/effective-java-item1/"},"frontmatter":{"date":"Dec 13, 2021","update":"Jan 01, 0001","title":"[이펙티브 자바] 1. 생성자 대신 정적 팩터리 메서드를 고려하라","tags":["java","book"]}}},{"node":{"excerpt":"보통 로깅을 위해서 System.out.println() 보다는 logback 이나 log4j 같은 로깅 프레임워크를 사용하는 것이 좋다고 한다. 로깅 프레임워크를 사용하면 로깅 레벨을 설정할 수 있다는 점이 좋다고는 알고 있지만 성능상으로도 더 좋…","fields":{"slug":"/sout-vs-logger/"},"frontmatter":{"date":"Dec 01, 2021","update":"Jan 01, 0001","title":"System.out.println() vs Logger","tags":["java","logger"]}}},{"node":{"excerpt":"POJO (Plain Old Java Object) POJO는 Plain Old Java Object의 준말로 말 그대로 오래된 방식의 간단한 자바 오브젝트라는 뜻이다. Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된…","fields":{"slug":"/pojo-vs-java-beans/"},"frontmatter":{"date":"Jun 13, 2021","update":"Jan 01, 0001","title":"POJO vs Java Beans","tags":["java","spring"]}}},{"node":{"excerpt":"Validation이란? Validation이란 유효성 검증을 의미한다. 대표적인 예로 String의 값이 null이 되면 안된다던가 Integer의 값이 0보다 커야한다던가 즉, 우테코에서 미션을 진행해오면서 보통 도메인에서 처리했었던 검증을 말한…","fields":{"slug":"/java-validation/"},"frontmatter":{"date":"Jun 10, 2021","update":"Jan 01, 0001","title":"Java Validation 파헤치기","tags":["java","spring"]}}},{"node":{"excerpt":"Servlet 컨테이너는 서블릿을 실행하고 관리한다. 컨테이너가 주는 혜택 통신(커뮤니케이션) 지원 컨테이너는 서블릿과 웹 서버가 서로 통신할 수 있는 손쉬운 방법을 제공. 서버와 대화하기 위해 개발자가 직접 ServcerSocket을 만들고, 특정…","fields":{"slug":"/servlet-dispatcherservlet/"},"frontmatter":{"date":"Jun 10, 2021","update":"Jan 01, 0001","title":"Servlet, DispatcherServlet 살펴보기","tags":["java","spring"]}}}]},{"fieldValue":"join","totalCount":1,"edges":[{"node":{"excerpt":"Cross Join? JPA 빌더인 QueryDSL을 사용하다보면 Join 쿼리 작성할 때 주의하지 않으면 Cross Join이 발생한다고 한다. 예전에 이동욱님 글에서 한번 본 적이 있었는데 당시에는 QueryDSL을 사용하고 있지 않던 터라 그냥…","fields":{"slug":"/cross-join/"},"frontmatter":{"date":"Sep 30, 2021","update":"Jan 01, 0001","title":"Cross Join 살펴보기","tags":["database","join"]}}}]},{"fieldValue":"jpql","totalCount":1,"edges":[{"node":{"excerpt":"기존 검색 API /api/search/workbooks?type=name&criteria=date&order=desc&keyword=JAVA&start=0&size=10 type: name, tag, user 중 택 1 (검색할 때 종류) crit…","fields":{"slug":"/criteria-querydsl/"},"frontmatter":{"date":"Sep 27, 2021","update":"Jan 01, 0001","title":"Criteria -> QueryDSL 마이그레이션 해보기","tags":["jpql"]}}}]},{"fieldValue":"logback","totalCount":1,"edges":[{"node":{"excerpt":"프로젝트 로깅 문제 현재 보또보 프로젝트에서는 로깅을 위해 Logback을 사용하고 있다. 기본적으로 스프링에서 생기는 로그 + HTTP 요청 응답 로그 + JPA로 생기는 쿼리와 바인딩 데이터 로그를 남기기로 했다. Local, Test 환경에서는…","fields":{"slug":"/async-logging/"},"frontmatter":{"date":"Oct 02, 2021","update":"Jan 01, 0001","title":"로깅이 성능에 미치는 영향과 비동기 로깅","tags":["spring","logback"]}}}]},{"fieldValue":"logger","totalCount":1,"edges":[{"node":{"excerpt":"보통 로깅을 위해서 System.out.println() 보다는 logback 이나 log4j 같은 로깅 프레임워크를 사용하는 것이 좋다고 한다. 로깅 프레임워크를 사용하면 로깅 레벨을 설정할 수 있다는 점이 좋다고는 알고 있지만 성능상으로도 더 좋…","fields":{"slug":"/sout-vs-logger/"},"frontmatter":{"date":"Dec 01, 2021","update":"Jan 01, 0001","title":"System.out.println() vs Logger","tags":["java","logger"]}}}]},{"fieldValue":"mvc","totalCount":1,"edges":[{"node":{"excerpt":"Spring Framework는 자바 기반의 엔터프라이즈 애플리케이션을 위해서 여러가지 기능을 제공한다. 그 중 웹 애플리케이션 구현을 위한 모듈로 Spring Web MVC가 제공되는데 클라이언트가 요청을 하고 Spring Web MVC에 의해 응…","fields":{"slug":"/spring-mvc/"},"frontmatter":{"date":"Dec 07, 2021","update":"Jan 01, 0001","title":"Spring MVC 구조 파악하기","tags":["spring","mvc"]}}}]},{"fieldValue":"network","totalCount":6,"edges":[{"node":{"excerpt":"혼잡 제어(Congestion Control) 혼잡 상황이 발생하면 네트워크 자원이 낭비되므로 혼잡 상황을 최소화 하기 위한 기법 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다.\n송신측에서 라우터가 처…","fields":{"slug":"/congestion-control/"},"frontmatter":{"date":"Oct 23, 2021","update":"Jan 01, 0001","title":"혼잡 제어(Congestion Control)란?","tags":["network"]}}},{"node":{"excerpt":"01 서버의 개요 클라이언트와 서버의 차이점 공통점 네트워크에 관한 부분, 즉 LAN 어댑터, 프로토콜 스택, Socket 라이브러리 등의 기능은 클라이언트와 조금도 다르지 않다. 차이점 서버 머신은 용도에 따라 다양한 종류가 있고, 하드웨어나 OS…","fields":{"slug":"/1per-network-ch6/"},"frontmatter":{"date":"Oct 08, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 6장","tags":["network","book"]}}},{"node":{"excerpt":"01 웹 서버의 설치 장소 사내에 웹 서버를 설치하는 경우 인터넷을 빠져나와 서버에 도착할 때까지의 여정은 서버의 설치 장소에 따라 다름. Untitled - 2021-12-22T173836 683 라우터에서 직접 연결하는 경우 이전에는 이런 형태로…","fields":{"slug":"/1per-network-ch5/"},"frontmatter":{"date":"Oct 05, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 5장","tags":["network","book"]}}},{"node":{"excerpt":"01 케이블과 리피터, 허브 속을 신호가 흘러간다 하나하나의 패킷이 독립된 것으로 동작한다. 중계 동작은 패킷의 헤더에 기록된 제어 정보와 중계 장치의 내부에 있는 중계 대상을 등록한 표로 목적지를 판단하고 목적지에 가까워지도록 하여 패킷을 중계한다…","fields":{"slug":"/1per-network-ch3/"},"frontmatter":{"date":"Oct 01, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 3장","tags":["network","book"]}}},{"node":{"excerpt":"01 소켓을 작성한다. 프로토콜 스택의 내부 구성 KakaoTalk_20210929_220830699 네트워크 애플리케이션 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램 여기부터 아래로 향하여 데이터 송, 수신 등의 일을 의뢰함. 브라우저뿐…","fields":{"slug":"/1per-network-ch2/"},"frontmatter":{"date":"Sep 29, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 2장","tags":["network","os"]}}},{"node":{"excerpt":"01 HTTP 리퀘스트 메시지를 작성한다. 탐험의 여행은 URL 입력부터 시작한다. URL은 http: 뿐만 아니라 ftp:, file:, mailto: 로 시작하는 것 등 여러 가지가 있다. 브라우저는 몇 개의 클라이언트 기능을 겸비한 복합적인 클…","fields":{"slug":"/1per-network-ch1/"},"frontmatter":{"date":"Sep 25, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 1장","tags":["network","book"]}}}]},{"fieldValue":"os","totalCount":11,"edges":[{"node":{"excerpt":"1. 교착상태 특징 멀티 프로그래밍 환경에서는 여러 프로세스들이 한정된 자원을 사용하기 위해 경쟁하고 있으며, 한 프로세스가 자원을 요청했을 때 해당 자원이 사용 불가능한 상태라면 교착상태(Deadlock)가 발생하게 된다.\n즉, 요청한 자원을 다른…","fields":{"slug":"/deadlock/"},"frontmatter":{"date":"Oct 23, 2021","update":"Jan 01, 0001","title":"교착상태(Deadlock)란?","tags":["os"]}}},{"node":{"excerpt":"공유된 자원에 여러 프로세스들이 동시에 접근했을 경우 데이터 무결성에 문제가 발생할 수 있다. 이러한 문제를 해결하기 위해 동기화(Synchronization) 개념이 도입되었다. 즉 공유 데이터에 대하여 동시에 접근하려 할 때, 처리 순서에 상관없…","fields":{"slug":"/process-synchronization/"},"frontmatter":{"date":"Oct 21, 2021","update":"Jan 01, 0001","title":"프로세스 동기화란?","tags":["os"]}}},{"node":{"excerpt":"1. 디스크의 구조 Untitled (89) 디스크 외부에서는 디스크를 일정한 크기의 저장공간들로 이루어진 1차원 배열처럼 취급하게 되는데 이 일정한 크기의 저장공간을 논리블록(logical block)이라고 한다. 디스크에 데이터가 저장될 때에는 …","fields":{"slug":"/os-it-principle-ch9/"},"frontmatter":{"date":"Oct 18, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 9. 디스크 관리","tags":["os","book"]}}},{"node":{"excerpt":"시분할 환경에서는 한정된 메모리 공간을 여러 프로그램이 조금씩 나누어서 사용하다보니 운영체제는 어떤 프로그램에게 어느 정도의 메모리를 할당할 것인가 하는 문제에 당면하게 됨. 운영체제는 모든 프로그램들에게 공평하게 메모리를 할당하기보다는 몇몇 프로그…","fields":{"slug":"/os-it-principle-ch8/"},"frontmatter":{"date":"Oct 17, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 8. 가상메모리","tags":["os","book"]}}},{"node":{"excerpt":"컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소 체계를 사용하면 2의 32제곱 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다. 효율적인 운영을 위해 보통 4KB(= 2의 12제곱 byte) 단위로 묶어서 페이지…","fields":{"slug":"/os-it-principle-ch7/"},"frontmatter":{"date":"Oct 16, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 7. 메모리 관리","tags":["os","book"]}}},{"node":{"excerpt":"CPU는 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치. 일반적으로 한 시스템 내에 하나씩밖에 없으므로 시분할 환경에서 매우 효율적으로 관리되어야 하는 자원. 기계어 명령은 크게 CPU 내에서 수행되는 명령, 메모리 접근을 필요로…","fields":{"slug":"/os-it-principle-ch6/"},"frontmatter":{"date":"Oct 15, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 6. CPU 스케줄링","tags":["os","book"]}}},{"node":{"excerpt":"1. 프로세스의 개념 프로세스(process)란 실행 중인 프로그램(program in execution)을 뜻한다. 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스가 되며, 프로세스는 CPU를 획득해 자신의…","fields":{"slug":"/os-it-principle-ch5/"},"frontmatter":{"date":"Oct 14, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 5. 프로세스 관리","tags":["os","book"]}}},{"node":{"excerpt":"1. 프로그램의 구조와 인터럽트 컴퓨터 프로그램은 어떠한 프로그래밍 언어로 작성되었든 그 내부 구조는 함수들로 구성된다. 프로그램의 주소 영역은 크게 코드(code), 데이터(data), 스택(stack) 영역으로 구분됨. 코드 영역 - 우리가 작성…","fields":{"slug":"/os-it-principle-ch4/"},"frontmatter":{"date":"Oct 13, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 4. 프로그램의 구조와 실행","tags":["os","book"]}}},{"node":{"excerpt":"1. 컴퓨터 시스템의 구조 컴퓨터 내부장치인 CPU, 메모리와 컴퓨터 외부장치인 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등으로 구성된다. 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 그 결과를 외부장치로 다시 …","fields":{"slug":"/os-it-principle-ch3/"},"frontmatter":{"date":"Oct 12, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 3. 컴퓨터 시스템의 동작 원리","tags":["os","book"]}}},{"node":{"excerpt":"1. 운영체제의 정의 운영체제란 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어 Untitled (67) 운영체제에 시스템이라는 용어가 사용된 것은 하드웨어가 운영체제와 한 몸이 되어야만 사용자에게 쓰일 수 있는 진정한 컴퓨터 시스템이 되기 때문. …","fields":{"slug":"/os-it-principle-ch2/"},"frontmatter":{"date":"Oct 11, 2021","update":"Jan 01, 0001","title":"[운영체제와 정보기술의 원리] 2. 운영체제의 개요","tags":["os","book"]}}},{"node":{"excerpt":"01 소켓을 작성한다. 프로토콜 스택의 내부 구성 KakaoTalk_20210929_220830699 네트워크 애플리케이션 브라우저, 메일러, 웹 서버, 메일 서버 등의 프로그램 여기부터 아래로 향하여 데이터 송, 수신 등의 일을 의뢰함. 브라우저뿐…","fields":{"slug":"/1per-network-ch2/"},"frontmatter":{"date":"Sep 29, 2021","update":"Jan 01, 0001","title":"[성공과 실패를 결정하는 1%의 네트워크 원리] 2장","tags":["network","os"]}}}]},{"fieldValue":"redis","totalCount":2,"edges":[{"node":{"excerpt":"Cache 구조 #1 - Look aside Cache #2 - Write Back Redis는 Collection을 제공 왜 Collection이 중요한가? 개발의 편의성 랭킹 서버를 직접 구현한다면? 가장 간단한 방법 DB에 유저의 Score를 …","fields":{"slug":"/woowa-redis/"},"frontmatter":{"date":"Dec 18, 2021","update":"Jan 01, 0001","title":"우아한레디스를 보고 정리","tags":["redis"]}}},{"node":{"excerpt":"무엇을 캐싱했을까? 보고 또 보고 에서는 문제집 검색 기능을 제공한다. 검색 기능이 고도화되면서 키워드로 검색된 문제집 결과에 유저, 태그로 필터해주는 기능도 추가되었다. 이렇게만 들었을 때는 '검색된 문제집들의 유저와 태그 리스트가 있을테니 이를 …","fields":{"slug":"/redis-cache/"},"frontmatter":{"date":"Dec 04, 2021","update":"Jan 01, 0001","title":"보또보에서 캐싱을 통해 성능 개선하기","tags":["redis","cache"]}}}]},{"fieldValue":"replication","totalCount":1,"edges":[{"node":{"excerpt":"Master & Slave DB 설치 Master DB 설정 아래 파일에서 설정 수정 Untitled (55)\nUntitled (56) mariadb 재시작 master db의 File과 Position 값을 slave db에 설정해야함 Untitl…","fields":{"slug":"/replication/"},"frontmatter":{"date":"Sep 29, 2021","update":"Jan 01, 0001","title":"DB Replication 따라해보기","tags":["database","replication"]}}}]},{"fieldValue":"spring","totalCount":9,"edges":[{"node":{"excerpt":"Spring Framework는 자바 기반의 엔터프라이즈 애플리케이션을 위해서 여러가지 기능을 제공한다. 그 중 웹 애플리케이션 구현을 위한 모듈로 Spring Web MVC가 제공되는데 클라이언트가 요청을 하고 Spring Web MVC에 의해 응…","fields":{"slug":"/spring-mvc/"},"frontmatter":{"date":"Dec 07, 2021","update":"Jan 01, 0001","title":"Spring MVC 구조 파악하기","tags":["spring","mvc"]}}},{"node":{"excerpt":"캐싱이라는 용어는 프로그래밍에서 자주 등장하게 된다.\n캐싱이란 '성능 향상을 위해 사용이 많은 데이터를 별도 공간에 일시적으로 저장하여 필요할 때마다 데이터를 가져오는 기술'이다.\n메모리, 네트워크 등 다양한 곳에서 사용하게 되는데 Spring에서도…","fields":{"slug":"/spring-cache/"},"frontmatter":{"date":"Dec 04, 2021","update":"Jan 01, 0001","title":"Spring Cache 살펴보기","tags":["spring","cache"]}}},{"node":{"excerpt":"프로젝트 로깅 문제 현재 보또보 프로젝트에서는 로깅을 위해 Logback을 사용하고 있다. 기본적으로 스프링에서 생기는 로그 + HTTP 요청 응답 로그 + JPA로 생기는 쿼리와 바인딩 데이터 로그를 남기기로 했다. Local, Test 환경에서는…","fields":{"slug":"/async-logging/"},"frontmatter":{"date":"Oct 02, 2021","update":"Jan 01, 0001","title":"로깅이 성능에 미치는 영향과 비동기 로깅","tags":["spring","logback"]}}},{"node":{"excerpt":"@Profile, @ActiveProfiles 이 두 애노테이션을 알아보기 전에 Profile이란 무엇인지에 대해 알아보자. 미니 프로젝트가 아닌 대부분의 기업용 서비스는 보통 개발(dev), 테스트(test), 운영(prod) 등으로 구동 환경을 …","fields":{"slug":"/profile-activeprofiles/"},"frontmatter":{"date":"Aug 24, 2021","update":"Jan 01, 0001","title":"@Profile, @ActiveProfiles 란?","tags":["spring"]}}},{"node":{"excerpt":"RestAssured Test RestAssured는 REST 웹 서비스를 검증하기 위한 라이브러리. 대부분 End-to-End or 인수 테스트에서 사용된다. @SpringBootTest를 통해 애플리케이션에 등록될 빈을 모두 가져와 실제 요청을 …","fields":{"slug":"/restassured-vs-mockmvc/"},"frontmatter":{"date":"Jun 18, 2021","update":"Jan 01, 0001","title":"RestAssured Test vs MockMvc Test","tags":["spring","test"]}}},{"node":{"excerpt":"@SpringBootApplication 우테코에서 미션을 하며 스프링 부트를 이용해서 웹 애플리케이션을 만들어보았다. 스프링은 간단하게 이야기하면 스프링 빈 컨테이너를 만들어 빈 등록을 하고 필요한 객체에게 의존성 주입을 하는 방식으로 애플리케이션…","fields":{"slug":"/springboot-application/"},"frontmatter":{"date":"Jun 15, 2021","update":"Jan 01, 0001","title":"@SpringBootApplication 파헤치기","tags":["spring"]}}},{"node":{"excerpt":"POJO (Plain Old Java Object) POJO는 Plain Old Java Object의 준말로 말 그대로 오래된 방식의 간단한 자바 오브젝트라는 뜻이다. Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된…","fields":{"slug":"/pojo-vs-java-beans/"},"frontmatter":{"date":"Jun 13, 2021","update":"Jan 01, 0001","title":"POJO vs Java Beans","tags":["java","spring"]}}},{"node":{"excerpt":"Validation이란? Validation이란 유효성 검증을 의미한다. 대표적인 예로 String의 값이 null이 되면 안된다던가 Integer의 값이 0보다 커야한다던가 즉, 우테코에서 미션을 진행해오면서 보통 도메인에서 처리했었던 검증을 말한…","fields":{"slug":"/java-validation/"},"frontmatter":{"date":"Jun 10, 2021","update":"Jan 01, 0001","title":"Java Validation 파헤치기","tags":["java","spring"]}}},{"node":{"excerpt":"Servlet 컨테이너는 서블릿을 실행하고 관리한다. 컨테이너가 주는 혜택 통신(커뮤니케이션) 지원 컨테이너는 서블릿과 웹 서버가 서로 통신할 수 있는 손쉬운 방법을 제공. 서버와 대화하기 위해 개발자가 직접 ServcerSocket을 만들고, 특정…","fields":{"slug":"/servlet-dispatcherservlet/"},"frontmatter":{"date":"Jun 10, 2021","update":"Jan 01, 0001","title":"Servlet, DispatcherServlet 살펴보기","tags":["java","spring"]}}}]},{"fieldValue":"test","totalCount":1,"edges":[{"node":{"excerpt":"RestAssured Test RestAssured는 REST 웹 서비스를 검증하기 위한 라이브러리. 대부분 End-to-End or 인수 테스트에서 사용된다. @SpringBootTest를 통해 애플리케이션에 등록될 빈을 모두 가져와 실제 요청을 …","fields":{"slug":"/restassured-vs-mockmvc/"},"frontmatter":{"date":"Jun 18, 2021","update":"Jan 01, 0001","title":"RestAssured Test vs MockMvc Test","tags":["spring","test"]}}}]}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}